# Задача на ООП: шахматные фигуры — `check_move()`

![](https://media.istockphoto.com/id/529947625/ru/%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%BD%D0%B0%D1%8F/%D0%BF%D1%83%D1%81%D1%82%D0%BE%D0%B9-%D1%88%D0%B0%D1%85%D0%BC%D0%B0%D1%82%D0%BD%D0%B0%D1%8F-%D0%B4%D0%BE%D1%81%D0%BA%D0%B0.jpg?s=612x612&w=0&k=20&c=TS4aB4f1q4wCwYfZwmzWbttMJai_FESuXEk2IYb84Tk=)

## Цель

Реализовать иерархию классов шахматных фигур. Каждая фигура знает только свою стартовую позицию `(x, y)` и умеет проверять, возможен ли ход по правилам шахмат **внутри доски 8×8** на новые координаты `(x, y)`.

> В задаче **нет партии**: нет других фигур, шахов/матов и т. п. Проверяется только геометрия хода и границы доски.

---

## Координаты и описание

* Используем декартовые координаты: `x` — столбец, `y` — ряд.
* Диапазон допустимых значений: **1…8** по обеим осям.
* Стартовая позиция хранится как **единственный атрибут** `start_position: tuple[int, int]`.
* Метод проверки: `check_move(new_x: int, new_y: int) -> bool`.
* Если целевая клетка вне доски или совпадает со стартовой — ход **недопустим**.
* Перескоки/блокировки другими фигурами **не учитываются** (фигуры «одни на доске»).

---

## Правила ходов (упрощённые)

Опираемся на стандартные шахматные ходы без взятий и специальных правил (рокировка). Для пешки задаём направление **вверх** по `y` (из меньших `y` к большим), как если бы она была белой.

* **King (король)**: на 1 клетку в любом направлении.
* **Queen (ферзь)**: как ладья или слон.
* **Rook (ладья)**: по горизонтали или вертикали на любое число клеток.
* **Bishop (слон)**: по диагонали на любое число клеток.
* **Knight (конь)**: буквой «Г» — (±1, ±2) или (±2, ±1). Может «перепрыгивать».
* **Pawn (пешка)**:

  * обычный ход: на `(x, y+1)`;
  * из стартового ряда `y == 2`: разрешён двойной ход на `(x, y+2)`;
  * **диагональные взятия в этой задаче НЕ учитываем** (нет противника), поэтому диагональный ход — **недопустим**.

---

## Интерфейс и архитектура

* Базовый абстрактный класс `Piece` с:

  * атрибутом `start_position: tuple[int, int]`;
  * методом `check_move(new_x, new_y) -> bool` (абстрактный);
  * общими утилитами: проверка границ доски, совпадения клетки, модулей разницы координат.
* От него наследуются: `King`, `Queen`, `Rook`, `Bishop`, `Knight`, `Pawn`.



---

## Примеры ожидаемого поведения

Предположим, фигура стоит на `start=(4,4)` (кроме пешки):

* `King(4,4)`: ✅ `(5,5)`, `(3,4)`; ❌ `(6,6)` (слишком далеко), `(4,4)` (та же клетка).
* `Queen(4,4)`: ✅ `(4,8)`, `(1,1)`, `(7,4)`; ❌ `(5,6)` (не по прямой/диагонали), `(9,4)` (вне доски).
* `Rook(4,4)`: ✅ `(4,1)`, `(8,4)`; ❌ `(5,5)`.
* `Bishop(4,4)`: ✅ `(1,1)`, `(7,7)`, `(1,7)`; ❌ `(4,5)`.
* `Knight(4,4)`: ✅ `(5,6)`, `(3,6)`, `(6,5)`, `(2,5)`; ❌ `(6,6)`, `(4,5)`.
* `Pawn(4,2)`: ✅ `(4,3)`, `(4,4)`; ❌ `(4,5)`, `(5,3)`, `(4,2)`.


---

## P.S. В идеале добавить функцию или создать класс для проверки ходов всех фигур.Создать несколько фигур и проверить их ходы на корректность.

![](https://www.meme-arsenal.com/memes/03aa9dfb52fd73588beae4b0af40cf80.jpg)