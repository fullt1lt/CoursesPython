# Лекция 19. Нормализация, Аномалии, Нормальные формы, Транзакции, ACID, TCL, Backup

![normalization_db.jpg](image/normalization_db.jpg)

## Нормализация базы данных

**Нормализация данных** — это процесс организации данных в базе данных с целью уменьшения избыточности и улучшения целостности данных. Этот процесс включает в себя разделение больших таблиц на более мелкие и установление связей между ними. Нормализация помогает избежать аномалий при добавлении, обновлении и удалении данных. Важно понимать, что нормализация не только улучшает структуру базы данных, но и делает её более гибкой и масштабируемой. Это особенно важно в условиях растущих объемов данных и увеличивающихся требований к производительности.

### Почему мы вообще говорим о нормализации?

Представьте себе, что вы создаёте систему управления заказами в интернет-магазине. Допустим, у вас есть таблица, в которой хранятся клиенты, товары и информация о заказах.

Вам кажется логичным сделать одну большую таблицу со всей информацией:

| order_id | customer_name | email          | product   | price | quantity |
|----------|--------------|---------------|----------|------|----------|
| 1        | Иван         | ivan@mail.com | Телефон  | 1200 | 1        |
| 2        | Мария        | maria@mail.com | Ноутбук  | 2500 | 1        |
| 3        | Иван         | ivan@mail.com | Наушники | 500  | 2        |

Вроде бы удобно, но что будет, если:

- Клиент сменит email? Нам придётся искать и менять во всех заказах.
- Мы удалим заказ – а вдруг это был единственный заказ клиента, и теперь мы его потеряли?
- Нужно найти все товары? Нам придётся перебирать все строки, чтобы получить список уникальных товаров.

Это примеры аномалий в базе данных!

Нормализация – это процесс, который решает эти проблемы, разделяя данные на логичные части.

### Основные принципы нормализации

Нормализация данных основывается на нескольких ключевых принципах:

- Избыточность данных: Уменьшение дублирования данных для экономии места и повышения эффективности. Избыточность данных может привести к увеличению объема хранимой информации и усложнению процессов её обработки.
- Целостность данных: Обеспечение точности и согласованности данных в базе. Целостность данных гарантирует, что все данные в базе являются актуальными и непротиворечивыми.
- Аномалии данных: Избежание проблем при изменении данных, таких как аномалии вставки, обновления и удаления. Аномалии могут привести к некорректным данным и нарушению целостности базы данных.

Существует 6 + 3 **нормальные формы**, но на практике дальше чем 3-я нормальная форма почти никогда не применяется и они нужны скорее для академических исследований либо для очень специфических случаев.

## Аномалии

**Аномалии** – это некорректные ситуации в базе данных, возникающие из-за плохо спроектированной структуры таблиц. Давайте разберём три главные аномалии.

### Аномалия вставки (Insert Anomaly)

Допустим, у нас есть таблица, в которой хранятся заказы клиентов. Но если клиент только зарегистрировался, но ещё не сделал заказ, мы не можем его добавить в базу. Это происходит, потому что у нас нет отдельной таблицы для клиентов, и все данные хранятся в заказах.


| order_id | customer_name | email          | product   | price |
|----------|--------------|---------------|----------|------|
| NULL     | Иван         | ivan@mail.com | NULL     | NULL |

**Почему это проблема?**

- Мы не можем добавить клиента без заказа
- Нам приходится заполнять поля значениями `NULL`, что делает базу неаккуратной

**Как исправить?**

Чтобы клиент мог существовать даже без заказов, нужно создать отдельную таблицу клиентов `(customers)`. Теперь клиенты не зависят от заказов, и их можно добавлять без привязки к покупкам.

**Таблица customers (исправленный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |
m

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |
| 2        | 2          | Ноутбук  | 2500 |

Теперь клиент существует отдельно, а заказы ссылаются на него! Можно добавлять клиентов, даже если они ещё не покупали товары!

### Аномалия обновления (Update Anomaly)

- Допустим, клиент сменил `email`.
- Но если этот `email` хранится во всех заказах, нам нужно менять его в каждой строке!

Плохая структура (до исправления)

| order_id | customer_name | email          | product   |
|----------|--------------|---------------|----------|
| 1        | Иван         | ivan@mail.com | Телефон  |
| 3        | Иван         | ivan@mail.com | Наушники |

**Почему это проблема?**

Дублирование данных – `email` повторяется несколько раз
Если Иван сменит `email`, его придётся обновлять в каждой строке заказов

**Как исправить?**

Нужно вынести `email` в отдельную таблицу customers, чтобы он хранился только в одном месте.


**Таблица customers (исправленный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |
| 2        | 1          | Наушники | 500  |
| 3        | 2          | Ноутбук  | 2500 |

Теперь, если Иван сменит `email`, нам нужно обновить ТОЛЬКО ОДНУ строку в `customers`!

### Аномалия удаления (Delete Anomaly)

Если клиент сделал всего один заказ, и мы его удаляем, клиент полностью исчезает из базы!

Плохая структура (до исправления)

| order_id | customer_name | email          | product   |
|----------|--------------|---------------|----------|
| 1        | Иван         | ivan@mail.com | Телефон  |

**Что произойдёт, если мы удалим заказ?**

```sql
DELETE FROM orders WHERE order_id = 1;
```

Иван полностью исчез из базы, хотя мог бы сделать заказ в будущем!

**Как исправить?**

Нужно отделить клиентов от заказов, чтобы они существовали независимо.

**Таблица customers (исправленный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |

Теперь, если мы удалим заказ, клиент останется в базе! Клиенты существуют отдельно от заказов, и их можно удалять только вручную.

## Как избежать аномалий: Нормализация данных

### Почему это важно?

Мы разобрали три типа аномалий – вставки, обновления и удаления – и выяснили, что они возникают из-за неправильной структуры базы данных. Чтобы избежать этих проблем, используется нормализация – процесс приведения базы данных в такую форму, где данные хранятся корректно, без избыточности и несогласованности.

**Что такое нормализация?**

**Нормализация** – это процесс разбиения данных на несколько связанных таблиц, чтобы устранить дублирование, избежать аномалий и улучшить структуру базы данных.

> Важно понимать, что нормализация – это не просто рекомендация, а необходимость для построения правильных баз данных.

**Как происходит нормализация?**

Нормализация происходит поэтапно, и каждый этап называется нормальной формой (`NF - Normal Form`).

- Каждая следующая нормальная форма строится на основе предыдущей!
- Нельзя перескочить с `1NF` сразу в `3NF`. Нужно идти по порядку.

Опытные разработчики сразу проектируют базу данных в `3NF`, чтобы избежать проблем в будущем.

## Три нормальные формы (NF) с примерами

## Первая нормальная форма (1NF) – Устраняем повторяющиеся значения

**В чём проблема?**

В не нормализованных таблицах часто встречаются повторяющиеся или несамостоятельные значения, например список товаров в одной ячейке.

**Ошибка (до нормализации, не 1NF)**

| order_id | customer_name | email          | products              | price  |
|----------|--------------|---------------|----------------------|------|
| 1        | Иван         | ivan@mail.com | Телефон, Наушники   | 1700 |
| 2        | Мария        | maria@mail.com | Ноутбук              | 2500 |

Здесь сразу несколько проблем:

Поле `products` содержит несколько значений, что противоречит реляционной модели.
Нельзя работать с отдельными товарами – например, найти все заказы, где купили "Наушники".

Решение: приведение к `1NF` (разделяем данные)

**Таблица orders (нормализованный вариант)**

| order_id | customer_name | email          | product   | price |
|----------|--------------|---------------|----------|------|
| 1        | Иван         | ivan@mail.com | Телефон  | 1200 |
| 1        | Иван         | ivan@mail.com | Наушники | 500  |
| 2        | Мария        | maria@mail.com | Ноутбук  | 2500 |

Теперь в каждой ячейке только одно значение, и мы можем искать товары, анализировать их и изменять данные правильно.

## Вторая нормальная форма (2NF) – Убираем избыточность данных

**В чём проблема?**

После приведения к `1NF` мы всё ещё дублируем данные. Посмотрите на колонку `email` – он повторяется в каждом заказе одного клиента. Ошибка (до нормализации, не `2NF`)

| order_id | customer_name | email          | product   | price |
|----------|--------------|---------------|----------|------|
| 1        | Иван         | ivan@mail.com | Телефон  | 1200 |
| 1        | Иван         | ivan@mail.com | Наушники | 500  |
| 2        | Мария        | maria@mail.com | Ноутбук  | 2500 |

**Проблема:**

- Если клиент сменит `email`, придётся менять его в каждой строке.
- Дублирование данных увеличивает размер базы.

Решение: приведение ко `2NF` (разделяем клиенты и заказы)

**Таблица customers (нормализованный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (нормализованный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |
| 1        | 1          | Наушники | 500  |
| 2        | 2          | Ноутбук  | 2500 |

Теперь `email` хранится ТОЛЬКО в `customers`, и если он изменится, нужно обновить только одну строку!

##  Третья нормальная форма (3NF) – Убираем транзитивные зависимости

Третья нормальная форма требует выполнения условий второй нормальной формы и отсутствия транзитивных зависимостей.

### Транзитивная зависимость

Транзитивная зависимость возникает в реляционной базе данных, когда один неключевой атрибут (колонка) зависит от другого неключевого атрибута, а тот, в свою очередь, зависит от первичного ключа.

То есть, если в таблице есть атрибуты A, B и C, и если:

A -> B (B зависит от A)
B -> C (C зависит от B)
Тогда можно сказать, что A транзитивно определяет C через B (A -> C через B).

**В чём проблема?**

- Даже после приведения ко `2NF` может быть лишняя информация.
- Посмотрите на колонку `product_category` – она зависит не от заказа, а от продукта.

**Ошибка (до нормализации, не `3NF`)**

| order_id | customer_id | product   | price | product_category |
|----------|------------|----------|------|----------------|
| 1        | 1          | Телефон  | 1200 | Электроника   |
| 1        | 1          | Наушники | 500  | Электроника   |
| 2        | 2          | Ноутбук  | 2500 | Электроника   |

**Проблема:**

Если мы переименуем категорию товара, придётся менять её во всех заказах.

Решение: приведение к `3NF` (создаём таблицу `products`)

**Таблица categories (новая таблица для категорий)**

| category_id | category_name  |
|------------|---------------|
| 1          | Электроника   |
| 2          | Бытовая техника |

**Таблица products (нормализованная, без транзитивной зависимости)**

| product_id | product   | category_id |
|-----------|----------|------------|
| 1         | Телефон  | 1          |
| 2         | Наушники | 1          |
| 3         | Ноутбук  | 1          |

**Таблица orders (без изменений, привязана к `products`)**

| order_id | customer_id | product_id | price |
|----------|------------|-----------|------|
| 1        | 1          | 1         | 1200 |
| 1        | 1          | 2         | 500  |
| 2        | 2          | 3         | 2500 |

Теперь категории зависят только от товаров, а товары ссылаются на заказы.

### Финальная структура

Мы начали с того, что исправляли аномалии, из-за которых структура базы была неудобной и неэффективной. На этом пути мы разбили таблицы на связанные сущности и постепенно пришли к третьей нормальной форме (`3NF`).

Но даже после нормализации оставался важный вопрос:

**Где правильно хранить цену?**

Почему просто хранить цену в `orders` — не лучшая идея? Если бы цена была только в `orders`, мы бы фиксировали её только на момент покупки, но тогда нельзя было бы узнать текущую цену товара.

**Проблема:** нам пришлось бы искать последний заказ, чтобы определить, сколько сейчас стоит товар.

Поэтому нужны два отдельных поля для цены:

- Текущая цена (`current_price`) – хранится в `products` и меняется со временем.
- Цена на момент покупки (`purchase_price`) – фиксируется в `orders` и не изменяется.

**Таблица categories (справочник категорий)**

| category_id | category_name  |
|------------|---------------|
| 1          | Электроника   |
| 2          | Бытовая техника |

**Таблица products (справочник товаров с текущей ценой)**

| product_id | product   | category_id | current_price |
|-----------|----------|------------|--------------|
| 1         | Телефон  | 1          | 1500         |
| 2         | Наушники | 1          | 600          |
| 3         | Ноутбук  | 1          | 2700         |

**Таблица customers (справочник клиентов)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (фиксируем цену на момент покупки!)**

| order_id | customer_id | product_id | purchase_price | order_date |
|----------|------------|-----------|---------------|------------|
| 1        | 1          | 1         | 1200          | 2024-03-15 |
| 1        | 1          | 2         | 500           | 2024-03-15 |
| 2        | 2          | 3         | 2500          | 2024-03-16 |

### Как финальная структура решает все проблемы?

|  Проблема                                |  Решение                                      |
|-------------------------------------------|------------------------------------------------|
| Если цена товара меняется, старые заказы "исчезают" | Фиксируем `purchase_price` в `orders`        |
| Нельзя узнать актуальную цену товара    | Храним `current_price` в `products`          |
| Нельзя отслеживать историю цен          | Можно сравнивать `current_price` и `purchase_price` |
