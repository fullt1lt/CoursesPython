# Лекция 19. Нормализация, Аномалии, Нормальные формы, Транзакции, ACID, TCL, Backup

![normalization_db.jpg](image/normalization_db.jpg)

## Нормализация базы данных

**Нормализация данных** — это процесс организации данных в базе данных с целью уменьшения избыточности и улучшения целостности данных. Этот процесс включает в себя разделение больших таблиц на более мелкие и установление связей между ними. Нормализация помогает избежать аномалий при добавлении, обновлении и удалении данных. Важно понимать, что нормализация не только улучшает структуру базы данных, но и делает её более гибкой и масштабируемой. Это особенно важно в условиях растущих объемов данных и увеличивающихся требований к производительности.

### Почему мы вообще говорим о нормализации?

Представьте себе, что вы создаёте систему управления заказами в интернет-магазине. Допустим, у вас есть таблица, в которой хранятся клиенты, товары и информация о заказах.

Вам кажется логичным сделать одну большую таблицу со всей информацией:

| order_id | customer_name | email          | product   | price | quantity |
|----------|--------------|---------------|----------|------|----------|
| 1        | Иван         | ivan@mail.com | Телефон  | 1200 | 1        |
| 2        | Мария        | maria@mail.com | Ноутбук  | 2500 | 1        |
| 3        | Иван         | ivan@mail.com | Наушники | 500  | 2        |

Вроде бы удобно, но что будет, если:

- Клиент сменит email? Нам придётся искать и менять во всех заказах.
- Мы удалим заказ – а вдруг это был единственный заказ клиента, и теперь мы его потеряли?
- Нужно найти все товары? Нам придётся перебирать все строки, чтобы получить список уникальных товаров.

Это примеры аномалий в базе данных!

Нормализация – это процесс, который решает эти проблемы, разделяя данные на логичные части.

### Основные принципы нормализации

Нормализация данных основывается на нескольких ключевых принципах:

- Избыточность данных: Уменьшение дублирования данных для экономии места и повышения эффективности. Избыточность данных может привести к увеличению объема хранимой информации и усложнению процессов её обработки.
- Целостность данных: Обеспечение точности и согласованности данных в базе. Целостность данных гарантирует, что все данные в базе являются актуальными и непротиворечивыми.
- Аномалии данных: Избежание проблем при изменении данных, таких как аномалии вставки, обновления и удаления. Аномалии могут привести к некорректным данным и нарушению целостности базы данных.

Существует 6 + 3 **нормальные формы**, но на практике дальше чем 3-я нормальная форма почти никогда не применяется и они нужны скорее для академических исследований либо для очень специфических случаев.

## Аномалии

**Аномалии** – это некорректные ситуации в базе данных, возникающие из-за плохо спроектированной структуры таблиц. Давайте разберём три главные аномалии.

### Аномалия вставки (Insert Anomaly)

Допустим, у нас есть таблица, в которой хранятся заказы клиентов. Но если клиент только зарегистрировался, но ещё не сделал заказ, мы не можем его добавить в базу. Это происходит, потому что у нас нет отдельной таблицы для клиентов, и все данные хранятся в заказах.


| order_id | customer_name | email          | product   | price |
|----------|--------------|---------------|----------|------|
| NULL     | Иван         | ivan@mail.com | NULL     | NULL |

**Почему это проблема?**

- Мы не можем добавить клиента без заказа
- Нам приходится заполнять поля значениями `NULL`, что делает базу неаккуратной

**Как исправить?**

Чтобы клиент мог существовать даже без заказов, нужно создать отдельную таблицу клиентов `(customers)`. Теперь клиенты не зависят от заказов, и их можно добавлять без привязки к покупкам.

**Таблица customers (исправленный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |
m

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |
| 2        | 2          | Ноутбук  | 2500 |

Теперь клиент существует отдельно, а заказы ссылаются на него! Можно добавлять клиентов, даже если они ещё не покупали товары!

### Аномалия обновления (Update Anomaly)

- Допустим, клиент сменил `email`.
- Но если этот `email` хранится во всех заказах, нам нужно менять его в каждой строке!

Плохая структура (до исправления)

| order_id | customer_name | email          | product   |
|----------|--------------|---------------|----------|
| 1        | Иван         | ivan@mail.com | Телефон  |
| 3        | Иван         | ivan@mail.com | Наушники |

**Почему это проблема?**

Дублирование данных – `email` повторяется несколько раз
Если Иван сменит `email`, его придётся обновлять в каждой строке заказов

**Как исправить?**

Нужно вынести `email` в отдельную таблицу customers, чтобы он хранился только в одном месте.


**Таблица customers (исправленный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |
| 2        | 1          | Наушники | 500  |
| 3        | 2          | Ноутбук  | 2500 |

Теперь, если Иван сменит `email`, нам нужно обновить ТОЛЬКО ОДНУ строку в `customers`!

### Аномалия удаления (Delete Anomaly)

Если клиент сделал всего один заказ, и мы его удаляем, клиент полностью исчезает из базы!

Плохая структура (до исправления)

| order_id | customer_name | email          | product   |
|----------|--------------|---------------|----------|
| 1        | Иван         | ivan@mail.com | Телефон  |

**Что произойдёт, если мы удалим заказ?**

```sql
DELETE FROM orders WHERE order_id = 1;
```

Иван полностью исчез из базы, хотя мог бы сделать заказ в будущем!

**Как исправить?**

Нужно отделить клиентов от заказов, чтобы они существовали независимо.

**Таблица customers (исправленный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |

Теперь, если мы удалим заказ, клиент останется в базе! Клиенты существуют отдельно от заказов, и их можно удалять только вручную.

## Как избежать аномалий: Нормализация данных

### Почему это важно?

Мы разобрали три типа аномалий – вставки, обновления и удаления – и выяснили, что они возникают из-за неправильной структуры базы данных. Чтобы избежать этих проблем, используется нормализация – процесс приведения базы данных в такую форму, где данные хранятся корректно, без избыточности и несогласованности.

**Что такое нормализация?**

**Нормализация** – это процесс разбиения данных на несколько связанных таблиц, чтобы устранить дублирование, избежать аномалий и улучшить структуру базы данных.

> Важно понимать, что нормализация – это не просто рекомендация, а необходимость для построения правильных баз данных.

**Как происходит нормализация?**

Нормализация происходит поэтапно, и каждый этап называется нормальной формой (`NF - Normal Form`).

- Каждая следующая нормальная форма строится на основе предыдущей!
- Нельзя перескочить с `1NF` сразу в `3NF`. Нужно идти по порядку.

Опытные разработчики сразу проектируют базу данных в `3NF`, чтобы избежать проблем в будущем.

## Три нормальные формы (NF) с примерами

## Первая нормальная форма (1NF) – Устраняем повторяющиеся значения

**В чём проблема?**

В не нормализованных таблицах часто встречаются повторяющиеся или несамостоятельные значения, например список товаров в одной ячейке.

**Ошибка (до нормализации, не 1NF)**

| order_id | customer_name | email          | products              | price  |
|----------|--------------|---------------|----------------------|------|
| 1        | Иван         | ivan@mail.com | Телефон, Наушники   | 1700 |
| 2        | Мария        | maria@mail.com | Ноутбук              | 2500 |

Здесь сразу несколько проблем:

Поле `products` содержит несколько значений, что противоречит реляционной модели.
Нельзя работать с отдельными товарами – например, найти все заказы, где купили "Наушники".

Решение: приведение к `1NF` (разделяем данные)

**Таблица orders (нормализованный вариант)**

| order_id | customer_name | email          | product   | price |
|----------|--------------|---------------|----------|------|
| 1        | Иван         | ivan@mail.com | Телефон  | 1200 |
| 1        | Иван         | ivan@mail.com | Наушники | 500  |
| 2        | Мария        | maria@mail.com | Ноутбук  | 2500 |

Теперь в каждой ячейке только одно значение, и мы можем искать товары, анализировать их и изменять данные правильно.

## Вторая нормальная форма (2NF) – Убираем избыточность данных

**В чём проблема?**

После приведения к `1NF` мы всё ещё дублируем данные. Посмотрите на колонку `email` – он повторяется в каждом заказе одного клиента. Ошибка (до нормализации, не `2NF`)

| order_id | customer_name | email          | product   | price |
|----------|--------------|---------------|----------|------|
| 1        | Иван         | ivan@mail.com | Телефон  | 1200 |
| 1        | Иван         | ivan@mail.com | Наушники | 500  |
| 2        | Мария        | maria@mail.com | Ноутбук  | 2500 |

**Проблема:**

- Если клиент сменит `email`, придётся менять его в каждой строке.
- Дублирование данных увеличивает размер базы.

Решение: приведение ко `2NF` (разделяем клиенты и заказы)

**Таблица customers (нормализованный вариант)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (нормализованный вариант)**

| order_id | customer_id | product   | price |
|----------|------------|----------|------|
| 1        | 1          | Телефон  | 1200 |
| 1        | 1          | Наушники | 500  |
| 2        | 2          | Ноутбук  | 2500 |

Теперь `email` хранится ТОЛЬКО в `customers`, и если он изменится, нужно обновить только одну строку!

##  Третья нормальная форма (3NF) – Убираем транзитивные зависимости

Третья нормальная форма требует выполнения условий второй нормальной формы и отсутствия транзитивных зависимостей.

### Транзитивная зависимость

Транзитивная зависимость возникает в реляционной базе данных, когда один неключевой атрибут (колонка) зависит от другого неключевого атрибута, а тот, в свою очередь, зависит от первичного ключа.

То есть, если в таблице есть атрибуты A, B и C, и если:

A -> B (B зависит от A)
B -> C (C зависит от B)
Тогда можно сказать, что A транзитивно определяет C через B (A -> C через B).

**В чём проблема?**

- Даже после приведения ко `2NF` может быть лишняя информация.
- Посмотрите на колонку `product_category` – она зависит не от заказа, а от продукта.

**Ошибка (до нормализации, не `3NF`)**

| order_id | customer_id | product   | price | product_category |
|----------|------------|----------|------|----------------|
| 1        | 1          | Телефон  | 1200 | Электроника   |
| 1        | 1          | Наушники | 500  | Электроника   |
| 2        | 2          | Ноутбук  | 2500 | Электроника   |

**Проблема:**

Если мы переименуем категорию товара, придётся менять её во всех заказах.

Решение: приведение к `3NF` (создаём таблицу `products`)

**Таблица categories (новая таблица для категорий)**

| category_id | category_name  |
|------------|---------------|
| 1          | Электроника   |
| 2          | Бытовая техника |

**Таблица products (нормализованная, без транзитивной зависимости)**

| product_id | product   | category_id |
|-----------|----------|------------|
| 1         | Телефон  | 1          |
| 2         | Наушники | 1          |
| 3         | Ноутбук  | 1          |

**Таблица orders (без изменений, привязана к `products`)**

| order_id | customer_id | product_id | price |
|----------|------------|-----------|------|
| 1        | 1          | 1         | 1200 |
| 1        | 1          | 2         | 500  |
| 2        | 2          | 3         | 2500 |

Теперь категории зависят только от товаров, а товары ссылаются на заказы.

### Финальная структура

Мы начали с того, что исправляли аномалии, из-за которых структура базы была неудобной и неэффективной. На этом пути мы разбили таблицы на связанные сущности и постепенно пришли к третьей нормальной форме (`3NF`).

Но даже после нормализации оставался важный вопрос:

**Где правильно хранить цену?**

Почему просто хранить цену в `orders` — не лучшая идея? Если бы цена была только в `orders`, мы бы фиксировали её только на момент покупки, но тогда нельзя было бы узнать текущую цену товара.

**Проблема:** нам пришлось бы искать последний заказ, чтобы определить, сколько сейчас стоит товар.

Поэтому нужны два отдельных поля для цены:

- Текущая цена (`current_price`) – хранится в `products` и меняется со временем.
- Цена на момент покупки (`purchase_price`) – фиксируется в `orders` и не изменяется.

**Таблица categories (справочник категорий)**

| category_id | category_name  |
|------------|---------------|
| 1          | Электроника   |
| 2          | Бытовая техника |

**Таблица products (справочник товаров с текущей ценой)**

| product_id | product   | category_id | current_price |
|-----------|----------|------------|--------------|
| 1         | Телефон  | 1          | 1500         |
| 2         | Наушники | 1          | 600          |
| 3         | Ноутбук  | 1          | 2700         |

**Таблица customers (справочник клиентов)**

| customer_id | name  | email          |
|------------|------|---------------|
| 1          | Иван  | ivan@mail.com |
| 2          | Мария | maria@mail.com |

**Таблица orders (фиксируем цену на момент покупки!)**

| order_id | customer_id | product_id | purchase_price | order_date |
|----------|------------|-----------|---------------|------------|
| 1        | 1          | 1         | 1200          | 2024-03-15 |
| 1        | 1          | 2         | 500           | 2024-03-15 |
| 2        | 2          | 3         | 2500          | 2024-03-16 |

### Как финальная структура решает все проблемы?

|  Проблема                                |  Решение                                      |
|-------------------------------------------|------------------------------------------------|
| Если цена товара меняется, старые заказы "исчезают" | Фиксируем `purchase_price` в `orders`        |
| Нельзя узнать актуальную цену товара    | Храним `current_price` в `products`          |
| Нельзя отслеживать историю цен          | Можно сравнивать `current_price` и `purchase_price` |

## Транзакции 

**Транзакции** — это фундаментальная концепция в работе с реляционными базами данных, которая обеспечивает целостность, согласованность и безопасность данных. При работе с базой данных нередко возникает необходимость группировать несколько SQL-операций в одну транзакцию, чтобы они выполнялись либо все вместе, либо не выполнялись вовсе. Если в процессе выполнения что-то пошло не так — например, сервер внезапно перезапустился или одна из операций завершилась с ошибкой — система должна гарантировать, что база не окажется в некорректном состоянии. Для этого используются транзакции и набор специальных команд `TCL (Transaction Control Language)`.

### 1. Что такое транзакция в SQL?

**Транзакция** – это группа операций, выполняемых над базой данных, которые должны быть выполнены все вместе или не выполнены вообще.

В жизни мы постоянно сталкиваемся с ситуациями, которые можно представить как транзакции.
Например, представьте, что вы покупаете товар в интернет-магазине:

     1. Вы добавили товар в корзину.
     2. Вы оформили заказ.
     3. Магазин списал деньги с вашей карты.
     4. В базе данных изменился статус заказа на "Оплачен".

Если всё прошло успешно, товар будет отправлен. Но представьте, что во время оплаты произошёл сбой, и деньги списались с вашей карты, но заказ не оформился. Это ошибка, и такая ситуация не должна происходить. Транзакции помогают избежать таких проблем: либо все действия выполняются полностью, либо ничего не выполняется вообще.

### 2. Принципы работы транзакций (ACID)

Транзакции должны быть надёжными. В базах данных надёжность обеспечивается четырьмя основными принципами, известными как `ACID`:

![ACID.png](image/ACID.png)

### Атомарность (Atomicity)

Транзакция выполняется полностью или не выполняется вообще. Если при выполнении произошла ошибка, база возвращается в начальное состояние.

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

-- Ошибка: счёт не существует
UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 99;

ROLLBACK; -- Все изменения отменяются
```

### Согласованность (Consistency)

После выполнения транзакции база данных должна оставаться в корректном состоянии. Например, если товар куплен, он должен исчезнуть со склада.

```sql
START TRANSACTION;

INSERT INTO orders (order_id, customer_id, total_price) 
VALUES (1, 2, 1000);

-- Ошибка: клиент с таким ID не существует
ROLLBACK; -- Откатываем, база остаётся согласованной
```

### Изолированность (Isolation)

Параллельные транзакции не должны мешать друг другу. Если два пользователя одновременно покупают один и тот же товар, база данных должна обработать их корректно.

```sql
Копировать
Редактировать
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

UPDATE products 
SET stock = stock - 1 
WHERE product_id = 5;

COMMIT; -- Все изменения выполняются только после подтверждения
```

### Надёжность (Durability)

После подтверждения `(COMMIT)` изменения не могут быть потеряны, даже если сервер перезагрузится.

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

COMMIT; -- Изменения сохранены даже если сервер перезапустится
```

Принципы `ACID` позволяют транзакциям обеспечивать целостность данных и предотвращать ошибки.

### 3. TCL (Transaction Control Language) – Управление транзакциями в SQL

В SQL есть специальный набор команд, называемый `TCL (Transaction Control Language) `– это язык управления транзакциями, который помогает контролировать внесение изменений в базу данных. Транзакции позволяют группировать несколько SQL-операций в одну логическую единицу, которая выполняется либо полностью, либо не выполняется вовсе.

Команды TCL позволяют:

- Подтверждать изменения `(COMMIT)`
- Откатывать транзакции `(ROLLBACK)`
- Создавать точки сохранения `(SAVEPOINT)`
- Удалять точки отката `(RELEASE SAVEPOINT)`
- Настраивать поведение транзакции `(SET TRANSACTION)`

Теперь разберём каждую команду подробно с примерами.

#### 1 BEGIN TRANSACTION или START TRANSACTION – начало транзакции

Перед тем как выполнить несколько связанных операций, необходимо явно начать транзакцию.
Для этого используются две равнозначные команды:

```sql
BEGIN TRANSACTION;
```

или

```sql
START TRANSACTION;
```

Эта команда сообщает базе данных, что все последующие SQL-запросы будут частью одной транзакции.

Пример: Начинаем транзакцию перед переводом денег:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;
```

Теперь все изменения выполняются в рамках одной транзакции, но они ещё не зафиксированы. Если что-то пойдёт не так, можно отменить все изменения, а если всё хорошо – зафиксировать.

#### 2️ COMMIT – подтверждение транзакции

Когда все операции в транзакции выполнены успешно, их нужно зафиксировать в базе данных. Это делается с помощью команды `COMMIT`, которая делает все изменения постоянными.

```sql
COMMIT;
```

После выполнения `COMMIT` изменения невозможно отменить, даже если сервер перезагрузится.

Пример: Завершаем перевод денег и сохраняем изменения:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

COMMIT; -- Подтверждаем изменения
```

Теперь деньги гарантированно переведены, и даже если сервер перезапустится, изменения не пропадут.

### 3️ ROLLBACK – отмена всех изменений

Если во время выполнения транзакции произошла ошибка, можно отменить все изменения, вернув базу в исходное состояние.

Для этого используется команда:

```sql
ROLLBACK;
```

Пример:

Допустим, во время перевода денег на втором шаге произошёл сбой (например, у получателя вообще нет счёта).

Без `ROLLBACK` могли бы возникнуть проблемы:

Деньги списались, но не дошли до получателя → потеря денег!

Используем `ROLLBACK`, чтобы предотвратить это:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

-- Ошибка! Например, счёта 2 не существует
ROLLBACK; -- Все изменения отменяются
```

Теперь баланс на счёте 1 остался неизменным, и никакие деньги не пропали.

#### 4️ SAVEPOINT – создание точки отката

Иногда бывает ситуация, когда нужно отменить не всю транзакцию, а только её часть. Для этого можно использовать `SAVEPOINT` – он создаёт промежуточную точку, до которой можно вернуться.

```sql
SAVEPOINT save1;
```

Если нужно вернуться к этой точке, используется:

```sql
ROLLBACK TO save1;
```

Пример:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

SAVEPOINT step1; -- Создаём точку отката

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

ROLLBACK TO step1; -- Отменяем только вторую операцию

COMMIT; -- Подтверждаем оставшиеся изменения
```

Теперь деньги списались, но не были переведены на второй счёт.

#### 5️ RELEASE SAVEPOINT – удаление точки отката

Если точка сохранения `(SAVEPOINT)` больше не нужна, её можно удалить.

```sql
RELEASE SAVEPOINT save1;
```

После удаления `SAVEPOINT` нельзя откатиться к нему.

Пример:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

SAVEPOINT step1; -- Создаём точку отката

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

RELEASE SAVEPOINT step1; -- Удаляем точку сохранения

COMMIT; -- Подтверждаем изменения
```

Теперь `step1` больше нельзя использовать для отката.

#### 6️ SET TRANSACTION – настройка параметров транзакции

Иногда требуется изменить поведение транзакции. Для этого используется команда `SET TRANSACTION`.

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

Изоляция транзакции определяет, как параллельные транзакции влияют друг на друга.

**Уровни изоляции в PostgreSQL**

| Уровень изоляции      | Описание |
|-----------------------|--------------------------------------------------------------------|
| **READ UNCOMMITTED**  | Транзакция может видеть изменения других незавершённых транзакций. |
| **READ COMMITTED** *(по умолчанию)* | Транзакция не видит незавершённые изменения других транзакций. |
| **REPEATABLE READ**   | Транзакция видит только данные на момент её начала, даже если другие транзакции меняют их. |
| **SERIALIZABLE**      | Самый строгий уровень – транзакции выполняются так, как будто они идут одна за другой. |

**Примеры для каждого уровня изоляции транзакций в PostgreSQL**

##### **1️ READ UNCOMMITTED** – Чтение незавершённых изменений  

- Позволяет одной транзакции видеть изменения другой **даже до их `COMMIT`**.  
- Может привести к **грязному чтению (dirty read)**, когда данные читаются до окончательного подтверждения.

 **Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
UPDATE products SET price = price + 100 WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT * FROM products WHERE product_id = 1; -- Покажет цену, даже если транзакция 1 не сделала COMMIT
```

**Опасность:** Если транзакция 1 выполнит `ROLLBACK`, транзакция 2 увидела неверные данные.

##### **2️ READ COMMITTED** – Чтение только подтверждённых изменений

Транзакция не видит изменений других транзакций, пока они не зафиксированы `(COMMIT)`. Это уровень по умолчанию в PostgreSQL.

**Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
UPDATE products SET price = price + 100 WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM products WHERE product_id = 1; -- Пока не увидит новое значение цены, так как нет COMMIT
```

**Безопасность:** Транзакция 2 никогда не увидит незавершённые изменения.

##### **3️ REPEATABLE READ** – Повторяемое чтение

Гарантирует, что в рамках одной транзакции чтение данных не изменится, даже если параллельные транзакции их обновляют. Защищает от фантомных чтений (phantom read), но не предотвращает вставку новых строк.

**Пример:**


```sql
-- Транзакция 1
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM products WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
UPDATE products SET price = price + 100 WHERE product_id = 1;
COMMIT;

-- Транзакция 1 (повторный запрос)
SELECT * FROM products WHERE product_id = 1; -- Увидит старые данные, так как работает в рамках одного снимка (snapshot)
COMMIT;
```

**Безопасность:** Даже после COMMIT в транзакции 2 транзакция 1 видит данные, которые были на момент её начала.

##### **4️ SERIALIZABLE** – Полная изоляция транзакций

Самый строгий уровень изоляции. Транзакции выполняются так, как будто они идут одна за другой. Гарантирует полную защиту от фантомных и грязных чтений. Может вызвать конфликты при параллельных изменениях.

**Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM products WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
UPDATE products SET price = price + 100 WHERE product_id = 1;
COMMIT;

-- Транзакция 1 (попытка обновления)
UPDATE products SET price = price + 200 WHERE product_id = 1; 
-- Ошибка: "could not serialize access due to concurrent update"
ROLLBACK;
```

**Опасность:** Если две параллельные транзакции изменяют одну и ту же строку, одна из них будет принудительно откатана (ROLLBACK).

## Backup

![](https://cs14.pikabu.ru/post_img/2021/09/17/7/1631876621194950069.jpg)

> Есть два вида людей: 
>   - которые делают бекапы
>   - и которые уже делают бекапы
>   
> © Джейсон Стетхем,  VI век до нашей эры

### Зачем нужен backup?

`Резервное копирование` — это процесс создания копии данных, которую можно использовать для восстановления базы данных в случае потери данных или повреждения. Основные причины, по которым необходимо делать резервные копии:

1. **Защита от потери данных**: Аппаратные сбои, ошибки пользователей, атаки вирусов и хакеров могут привести к потере данных.
2. **Восстановление после сбоев**: Возможность быстро восстановить работоспособность базы данных после сбоя.
3. **Исторические данные**: Возможность доступа к старым версиям данных для анализа или аудита.
4. **Разработка и тестирование**: Копии данных могут использоваться для разработки, тестирования и экспериментов без риска повреждения основной базы данных.

### pg_dump

`pg_dump` — это утилита для создания резервных копий базы данных PostgreSQL. Она позволяет экспортировать данные и схему базы данных в файл.

#### Основные функции и параметры pg_dump

1. **Экспорт всей базы данных:**
   ```sh
   pg_dump -U username -h hostname -d dbname > backup.sql
   ```
   Параметры:
   - `-U`: имя пользователя.
   - `-h`: хост, на котором работает база данных.
   - `-d`: имя базы данных.

2. **Экспорт в формат tar или custom:**
   ```sh
   pg_dump -U username -h hostname -d dbname -F t > backup.tar
   ```
   Параметр `-F` указывает формат резервной копии:
   - `p`: plain текст (по умолчанию).
   - `c`: custom.
   - `t`: tar.

3. **Экспорт конкретной таблицы:**
   ```sh
   pg_dump -U username -h hostname -d dbname -t tablename > table_backup.sql
   ```
   Параметр `-t` указывает таблицу для экспорта.

4. **Сжатие резервной копии:**
   ```sh
   pg_dump -U username -h hostname -d dbname | gzip > backup.sql.gz
   ```

#### Примеры использования

- Экспорт всей базы данных с указанием формата:
  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -F c > mydatabase.backup
  ```

- Экспорт схемы без данных:
  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -s > schema_only.sql
  ```

- Экспорт данных без схемы:
  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -a > data_only.sql
  ```

### pg_restore

`pg_restore` — это утилита для восстановления базы данных из резервной копии, созданной с помощью `pg_dump` в формате tar или custom.

#### Основные функции и параметры pg_restore

1. **Восстановление базы данных:**
   ```sh
   pg_restore -U username -h hostname -d dbname backup_file
   ```

2. **Создание новой базы данных и восстановление:**
   ```sh
   createdb -U username -h hostname new_dbname
   pg_restore -U username -h hostname -d new_dbname backup_file
   ```

3. **Восстановление только схемы:**
   ```sh
   pg_restore -U username -h hostname -d dbname -s backup_file
   ```

4. **Восстановление только данных:**
   ```sh
   pg_restore -U username -h hostname -d dbname -a backup_file
   ```

#### Примеры использования

- Восстановление базы данных из tar-архива:
  ```sh
  pg_restore -U postgres -h localhost -d mydatabase mydatabase.backup
  ```

- Восстановление с применением дополнительных параметров:
  ```sh
  pg_restore -U postgres -h localhost -d mydatabase -j 4 --verbose mydatabase.backup
  ```
  Параметр `-j` указывает количество параллельных потоков для ускорения процесса восстановления.

### Практические советы

1. **Планирование резервного копирования:** Регулярно выполняйте резервное копирование базы данных, особенно перед внесением значительных изменений.

2. **Проверка резервных копий:** Периодически проверяйте резервные копии, чтобы убедиться, что они корректно восстанавливаются.

3. **Автоматизация:** Настройте автоматическое резервное копирование с помощью cron или других планировщиков задач.

4. **Безопасность:** Храните резервные копии в безопасных местах и защищайте их паролями или шифрованием.

5. **Документация:** Ведите документацию по процессу резервного копирования и восстановления, чтобы упростить обучение новых сотрудников и улучшить управляемость.

> Использование `pg_dump` и `pg_restore` позволяет эффективно управлять резервными копиями и восстанавливать данные в PostgreSQL. Эти утилиты предоставляют гибкость и надежность, необходимые для обеспечения безопасности и доступности данных. Регулярное резервное копирование и проверка его целостности — залог стабильной работы любой системы управления базами данных.

### Примеры использования

1. **Регулярное резервное копирование**: В крупных компаниях, где потеря данных может привести к серьезным финансовым потерям, резервное копирование проводится ежедневно.
2. **Восстановление после сбоя**: Если база данных повреждена из-за сбоя оборудования, можно быстро восстановить данные из последнего бэкапа.
3. **Создание тестовых сред**: Разработчики могут использовать резервные копии для создания тестовых баз данных, что позволяет тестировать новые функции без риска для основной базы.

> Резервное копирование и восстановление — это критически важные процессы для обеспечения безопасности данных в PostgreSQL. Понимание различных методов резервного копирования и восстановления поможет вам эффективно управлять базами данных и минимизировать риски потери данных. Спасибо за внимание!