# Лекция 19. Нормализация, Аномалии, Нормальные формы, Транзакции, ACID, TCL, Backup

![normalization_db.jpg](image/normalization_db.jpg)

## Нормализация базы данных

**Нормализация данных** — это процесс организации данных в базе данных с целью уменьшения избыточности и улучшения целостности данных. Этот процесс включает в себя разделение больших таблиц на более мелкие и установление связей между ними. Нормализация помогает избежать аномалий при добавлении, обновлении и удалении данных. Важно понимать, что нормализация не только улучшает структуру базы данных, но и делает её более гибкой и масштабируемой. Это особенно важно в условиях растущих объемов данных и увеличивающихся требований к производительности.

### Почему мы вообще говорим о нормализации?

Представьте себе, что вы создаёте систему управления заказами в интернет-магазине. Допустим, у вас есть таблица, в которой хранятся клиенты, товары и информация о заказах.

Вам кажется логичным сделать одну большую таблицу со всей информацией:

| order_id | customer_name | email          | product          | price | quantity |
| -------- | ------------- | -------------- | ---------------- | ----- | -------- |
| 1        | Иван      | ivan@mail.com  | Телефон   | 1200  | 1        |
| 2        | Мария    | maria@mail.com | Ноутбук   | 2500  | 1        |
| 3        | Иван      | ivan@mail.com  | Наушники | 500   | 2        |

Вроде бы удобно, но что будет, если:

- Клиент сменит email? Нам придётся искать и менять во всех заказах.
- Мы удалим заказ – а вдруг это был единственный заказ клиента, и теперь мы его потеряли?
- Нужно найти все товары? Нам придётся перебирать все строки, чтобы получить список уникальных товаров.

Это примеры аномалий в базе данных!

Нормализация – это процесс, который решает эти проблемы, разделяя данные на логичные части.

### Основные принципы нормализации

Нормализация данных основывается на нескольких ключевых принципах:

- Избыточность данных: Уменьшение дублирования данных для экономии места и повышения эффективности. Избыточность данных может привести к увеличению объема хранимой информации и усложнению процессов её обработки.
- Целостность данных: Обеспечение точности и согласованности данных в базе. Целостность данных гарантирует, что все данные в базе являются актуальными и непротиворечивыми.
- Аномалии данных: Избежание проблем при изменении данных, таких как аномалии вставки, обновления и удаления. Аномалии могут привести к некорректным данным и нарушению целостности базы данных.

Существует 6 + 3 **нормальные формы**, но на практике дальше чем 3-я нормальная форма почти никогда не применяется и они нужны скорее для академических исследований либо для очень специфических случаев.

## Аномалии

**Аномалии** – это некорректные ситуации в базе данных, возникающие из-за плохо спроектированной структуры таблиц. Давайте разберём три главные аномалии.

### Аномалия вставки (Insert Anomaly)

Допустим, у нас есть таблица, в которой хранятся заказы клиентов. Но если клиент только зарегистрировался, но ещё не сделал заказ, мы не можем его добавить в базу. Это происходит, потому что у нас нет отдельной таблицы для клиентов, и все данные хранятся в заказах.

| order_id | customer_name | email         | product | price |
| -------- | ------------- | ------------- | ------- | ----- |
| NULL     | Иван      | ivan@mail.com | NULL    | NULL  |

**Почему это проблема?**

- Мы не можем добавить клиента без заказа
- Нам приходится заполнять поля значениями `NULL`, что делает базу неаккуратной

**Как исправить?**

Чтобы клиент мог существовать даже без заказов, нужно создать отдельную таблицу клиентов `(customers)`. Теперь клиенты не зависят от заказов, и их можно добавлять без привязки к покупкам.

**Таблица customers (исправленный вариант)**

| customer_id | name       | email          |
| ----------- | ---------- | -------------- |
| 1           | Иван   | ivan@mail.com  |
| 2           | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product        | price |
| -------- | ----------- | -------------- | ----- |
| 1        | 1           | Телефон | 1200  |
| 2        | 2           | Ноутбук | 2500  |

Теперь клиент существует отдельно, а заказы ссылаются на него! Можно добавлять клиентов, даже если они ещё не покупали товары!

### Аномалия обновления (Update Anomaly)

- Допустим, клиент сменил `email`.
- Но если этот `email` хранится во всех заказах, нам нужно менять его в каждой строке!

Плохая структура (до исправления)

| order_id | customer_name | email         | product          |
| -------- | ------------- | ------------- | ---------------- |
| 1        | Иван      | ivan@mail.com | Телефон   |
| 3        | Иван      | ivan@mail.com | Наушники |

**Почему это проблема?**

Дублирование данных – `email` повторяется несколько раз
Если Иван сменит `email`, его придётся обновлять в каждой строке заказов

**Как исправить?**

Нужно вынести `email` в отдельную таблицу customers, чтобы он хранился только в одном месте.

**Таблица customers (исправленный вариант)**

| customer_id | name       | email          |
| ----------- | ---------- | -------------- |
| 1           | Иван   | ivan@mail.com  |
| 2           | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product          | price |
| -------- | ----------- | ---------------- | ----- |
| 1        | 1           | Телефон   | 1200  |
| 2        | 1           | Наушники | 500   |
| 3        | 2           | Ноутбук   | 2500  |

Теперь, если Иван сменит `email`, нам нужно обновить ТОЛЬКО ОДНУ строку в `customers`!

### Аномалия удаления (Delete Anomaly)

Если клиент сделал всего один заказ, и мы его удаляем, клиент полностью исчезает из базы!

Плохая структура (до исправления)

| order_id | customer_name | email         | product        |
| -------- | ------------- | ------------- | -------------- |
| 1        | Иван      | ivan@mail.com | Телефон |

**Что произойдёт, если мы удалим заказ?**

```sql
DELETE FROM orders WHERE order_id = 1;
```

Иван полностью исчез из базы, хотя мог бы сделать заказ в будущем!

**Как исправить?**

Нужно отделить клиентов от заказов, чтобы они существовали независимо.

**Таблица customers (исправленный вариант)**

| customer_id | name       | email          |
| ----------- | ---------- | -------------- |
| 1           | Иван   | ivan@mail.com  |
| 2           | Мария | maria@mail.com |

**Таблица orders (исправленный вариант)**

| order_id | customer_id | product        | price |
| -------- | ----------- | -------------- | ----- |
| 1        | 1           | Телефон | 1200  |

Теперь, если мы удалим заказ, клиент останется в базе! Клиенты существуют отдельно от заказов, и их можно удалять только вручную.

## Как избежать аномалий: Нормализация данных

### Почему это важно?

Мы разобрали три типа аномалий – вставки, обновления и удаления – и выяснили, что они возникают из-за неправильной структуры базы данных. Чтобы избежать этих проблем, используется нормализация – процесс приведения базы данных в такую форму, где данные хранятся корректно, без избыточности и несогласованности.

**Как происходит нормализация?**

Нормализация происходит поэтапно, и каждый этап называется нормальной формой (`NF - Normal Form`).

- Каждая следующая нормальная форма строится на основе предыдущей!
- Нельзя перескочить с `1NF` сразу в `3NF`. Нужно идти по порядку.

Опытные разработчики сразу проектируют базу данных в `3NF`, чтобы избежать проблем в будущем.

## Три нормальные формы (NF)

Перед тем как изучать первую, вторую и третью нормальные формы (1NF, 2NF, 3NF), важно увидеть, с чего начинается нормализация. Часто начинающие разработчики проектируют базу так, как удобно "на глаз", без соблюдения принципов нормализации. Это приводит к повторению данных, логическим противоречиям и ошибкам при обновлении.

Рассмотрим типичную "неправильную" таблицу заказов в интернет-магазине:

### Таблица до нормализации (нарушены все три формы)

| order_id | customer_name | email                                | products                                   | total_price | category_names                                 |
| -------- | ------------- | ------------------------------------ | ------------------------------------------ | ----------- | ---------------------------------------------- |
| 1        | Иван      | [ivan@mail.com](mailto:ivan@mail.com)   | Телефон x1, Наушники x2     | 1700        | Электроника, Электроника |
| 2        | Мария    | [maria@mail.com](mailto:maria@mail.com) | Ноутбук x1                          | 2500        | Электроника                         |
| 3        | Иван      | [ivan@mail.com](mailto:ivan@mail.com)   | Микроволновка x1, Утюг x1 | 3200        | Бытовая техника, Техника  |

С этой плохой структуры мы и начнём. Далее — в каждом из следующих блоков мы будем улучшать эту таблицу, приводя её сначала к 1NF, потом к 2NF, затем к 3NF. В итоге получим структурированную и логичную базу данных, которая будет легко поддерживать и расширять.

## Первая нормальная форма (1NF) – Устраняем повторяющиеся значения

Первая нормальная форма запрещает повторяющиеся группы и списки значений в ячейках. Каждая ячейка должна содержать одно атомарное значение, а не список или комбинацию.

### Проблема в изначальной таблице:

| order_id | customer_name | email                              | products                                   | total_price | category_names                                 |
| -------- | ------------- | ---------------------------------- | ------------------------------------------ | ----------- | ---------------------------------------------- |
| 1        | Иван      | [ivan@mail.com](mailto:ivan@mail.com) | Телефон x1, Наушники x2     | 1700        | Электроника, Электроника |
| 3        | Иван      | [ivan@mail.com](mailto:ivan@mail.com) | Микроволновка x1, Утюг x1 | 3200        | Бытовая техника, Техника  |

Здесь `products` и `category_names` — это списки внутри одной ячейки. SQL не может эффективно фильтровать или обновлять отдельные товары и категории, когда они так записаны.

### Что делаем?

Разбиваем каждый товар из заказа на отдельную строку. Теперь одна строка = один товар в заказе.

| order_id | customer_name | email                                | product_name               | quantity | price_per_item | total_item_price |
| -------- | ------------- | ------------------------------------ | -------------------------- | -------- | -------------- | ---------------- |
| 1        | Иван      | [ivan@mail.com](mailto:ivan@mail.com)   | Телефон             | 1        | 1200           | 1200             |
| 1        | Иван      | [ivan@mail.com](mailto:ivan@mail.com)   | Наушники           | 2        | 250            | 500              |
| 2        | Мария    | [maria@mail.com](mailto:maria@mail.com) | Ноутбук             | 1        | 2500           | 2500             |
| 3        | Иван      | [ivan@mail.com](mailto:ivan@mail.com)   | Микроволновка | 1        | 1700           | 1700             |
| 3        | Иван      | [ivan@mail.com](mailto:ivan@mail.com)   | Утюг                   | 1        | 1500           | 1500             |

Обратите внимание: поле `total_item_price` удобно рассчитывать прямо при сохранении строки, чтобы потом не суммировать заново.

### Что мы выиграли?

- Можно найти все заказы с конкретным товаром (например, все, где купили «Наушники»).
- Можно подсчитать общее количество каждого товара по всем заказам.
- Мы избавились от списков в ячейках — каждая строка стала `"атомарной"`.

## Вторая нормальная форма (2NF) – Убираем избыточность данных

Чтобы таблица соответствовала `2NF`, она должна:

- Уже быть приведена к `1NF` (каждая ячейка содержит атомарное значение);
- Не содержать частичных зависимостей — то есть все неключевые поля должны зависеть от всего первичного ключа, а не от его части.

### Проблема в таблице после 1NF

В таблице, несмотря на атомарные значения, данные о клиенте (имя и email) повторяются в каждой строке, где есть заказ от этого клиента:

| order_id | customer_name | email         | product_name               | quantity | price_per_item | total_item_price |
| -------- | ------------- | ------------- | -------------------------- | -------- | -------------- | ---------------- |
| 1        | Иван      | ivan@mail.com | Телефон             | 1        | 1200           | 1200             |
| 1        | Иван      | ivan@mail.com | Наушники           | 2        | 250            | 500              |
| 3        | Иван      | ivan@mail.com | Микроволновка | 1        | 1700           | 1700             |

Поля `customer_name` и `email` зависят не от конкретной строки товара, а от клиента — они дублируются и засоряют таблицу.

### Что делаем?

- Выносим данные о клиентах в отдельную таблицу `customers`.
- В таблице заказов храним только `customer_id`.

**Таблица customers (новая таблица для клиентов):**

| customer_id | name       | email                                |
| ----------- | ---------- | ------------------------------------ |
| 1           | Иван   | [ivan@mail.com](mailto:ivan@mail.com)   |
| 2           | Мария | [maria@mail.com](mailto:maria@mail.com) |

**Таблица orders_2nf (нормализованная, без частичных зависимостей):**

| order_id | customer_id | product_name               | quantity | price_per_item | total_item_price |
| -------- | ----------- | -------------------------- | -------- | -------------- | ---------------- |
| 1        | 1           | Телефон             | 1        | 1200           | 1200             |
| 1        | 1           | Наушники           | 2        | 250            | 500              |
| 2        | 2           | Ноутбук             | 1        | 2500           | 2500             |
| 3        | 1           | Микроволновка | 1        | 1700           | 1700             |
| 3        | 1           | Утюг                   | 1        | 1500           | 1500             |

### Что мы выиграли?

- Данные о клиентах хранятся в одном месте, без дублирования.
- Если клиент изменит email — правим его один раз.
- Улучшилась целостность данных и уменьшился объём хранения.

## Третья нормальная форма (3NF) – Убираем транзитивные зависимости

Чтобы таблица соответствовала `3NF`, она должна:

- Уже быть приведена ко `2NF`;
- Не содержать транзитивных зависимостей — то есть ни одно неключевое поле не должно зависеть от другого неключевого поля.

### Транзитивная зависимость

Транзитивная зависимость возникает в реляционной базе данных, когда один неключевой атрибут (колонка) зависит от другого неключевого атрибута, а тот, в свою очередь, зависит от первичного ключа.

То есть, если в таблице есть атрибуты A, B и C, и если:

A -> B (B зависит от A)
B -> C (C зависит от B)
Тогда можно сказать, что A транзитивно определяет C через B (A -> C через B).

### Проблема в таблице после 2NF

После `2NF` у нас всё ещё есть поле `product_category`, которое логически зависит не от заказа, а от товара.

Вот как выглядела бы таблица заказов, если бы мы оставили `product_category` в ней:

| order\_id | customer\_id | product\_name              | product\_category             | quantity | price\_per\_item | total\_item\_price |
| --------- | ------------ | -------------------------- | ----------------------------- | -------- | ---------------- | ------------------ |
| 1         | 1            | Телефон             | Электроника        | 1        | 1200             | 1200               |
| 1         | 1            | Наушники           | Электроника        | 2        | 250              | 500                |
| 3         | 1            | Микроволновка | Бытовая техника | 1        | 1700             | 1700               |

Проблема: если мы хотим переименовать категорию *"Бытовая техника"* → *"Техника для дома"*, нам придётся изменить её в каждой строке заказа.

### Что делаем?

- Создаём справочник `categories` с уникальными категориями.
- Создаём таблицу `products`, в которой связываем каждый товар с категорией.
- В `orders` теперь ссылаемся только на `product_id`.

**Таблица categories (справочник категорий):**

| category\_id | category\_name                |
| ------------ | ----------------------------- |
| 1            | Электроника        |
| 2            | Бытовая техника |

**Таблица products (справочник товаров с категориями):**

| product\_id | product\_name              | category\_id | current\_price |
| ----------- | -------------------------- | ------------ | -------------- |
| 1           | Телефон             | 1            | 1500           |
| 2           | Наушники           | 1            | 600            |
| 3           | Ноутбук             | 1            | 2500           |
| 4           | Микроволновка | 2            | 1700           |
| 5           | Утюг                   | 2            | 1500           |

**Таблица orders (теперь без транзитивных зависимостей):**

| order\_id | customer\_id | product\_id | quantity | purchase\_price | order\_date |
| --------- | ------------ | ----------- | -------- | --------------- | ----------- |
| 1         | 1            | 1           | 1        | 1200            | 2024-03-01  |
| 1         | 1            | 2           | 2        | 250             | 2024-03-01  |
| 2         | 2            | 3           | 1        | 2500            | 2024-03-02  |
| 3         | 1            | 4           | 1        | 1700            | 2024-03-03  |
| 3         | 1            | 5           | 1        | 1500            | 2024-03-03  |

### Что мы выиграли?

| Проблема                                                                                | Решение                                                                                |
| ----------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| Категория зависит от товара, а не от заказа                  | Вынесли `category` в отдельную таблицу                              |
| Цена может меняться с течением времени                         | Добавили `purchase_price` в заказ, `current_price` — в товар         |
| Имена категорий и товаров обновляются в одном месте | Поддерживаем консистентность и переиспользование |

Таким образом, мы завершили нормализацию до `3NF`. Теперь структура базы максимально устойчива к дублированию, изменениям и масштабированию.

## Транзакции

**Транзакции** — это фундаментальная концепция в работе с реляционными базами данных, которая обеспечивает целостность, согласованность и безопасность данных. При работе с базой данных нередко возникает необходимость группировать несколько SQL-операций в одну транзакцию, чтобы они выполнялись либо все вместе, либо не выполнялись вовсе. Если в процессе выполнения что-то пошло не так — например, сервер внезапно перезапустился или одна из операций завершилась с ошибкой — система должна гарантировать, что база не окажется в некорректном состоянии. Для этого используются транзакции и набор специальных команд `TCL (Transaction Control Language)`.

### 1. Что такое транзакция в SQL?

**Транзакция** – это группа операций, выполняемых над базой данных, которые должны быть выполнены все вместе или не выполнены вообще.

В жизни мы постоянно сталкиваемся с ситуациями, которые можно представить как транзакции.
Например, представьте, что вы покупаете товар в интернет-магазине:

    1. Вы добавили товар в корзину.
     2. Вы оформили заказ.
     3. Магазин списал деньги с вашей карты.
     4. В базе данных изменился статус заказа на "Оплачен".

Если всё прошло успешно, товар будет отправлен. Но представьте, что во время оплаты произошёл сбой, и деньги списались с вашей карты, но заказ не оформился. Это ошибка, и такая ситуация не должна происходить. Транзакции помогают избежать таких проблем: либо все действия выполняются полностью, либо ничего не выполняется вообще.

### 2. Принципы работы транзакций (ACID)

Транзакции должны быть надёжными. В базах данных надёжность обеспечивается четырьмя основными принципами, известными как `ACID`:

![ACID.png](image/ACID.png)

### Атомарность (Atomicity)

Транзакция выполняется полностью или не выполняется вообще. Если при выполнении произошла ошибка, база возвращается в начальное состояние.

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

-- Ошибка: счёт не существует
UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 99;

ROLLBACK; -- Все изменения отменяются
```

### Согласованность (Consistency)

После выполнения транзакции база данных должна оставаться в корректном состоянии. Например, если товар куплен, он должен исчезнуть со склада.

```sql
START TRANSACTION;

INSERT INTO orders (order_id, customer_id, total_price) 
VALUES (1, 2, 1000);

-- Ошибка: клиент с таким ID не существует
ROLLBACK; -- Откатываем, база остаётся согласованной
```

### Изолированность (Isolation)

Параллельные транзакции не должны мешать друг другу. Если два пользователя одновременно покупают один и тот же товар, база данных должна обработать их корректно.

```sql
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

UPDATE products 
SET stock = stock - 1 
WHERE product_id = 5;

COMMIT; -- Все изменения выполняются только после подтверждения
```

### Надёжность (Durability)

После подтверждения `(COMMIT)` изменения не могут быть потеряны, даже если сервер перезагрузится.

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

COMMIT; -- Изменения сохранены даже если сервер перезапустится
```

Принципы `ACID` позволяют транзакциям обеспечивать целостность данных и предотвращать ошибки.

### 3. TCL (Transaction Control Language) – Управление транзакциями в SQL

В SQL есть специальный набор команд, называемый `TCL (Transaction Control Language) `– это язык управления транзакциями, который помогает контролировать внесение изменений в базу данных. Транзакции позволяют группировать несколько SQL-операций в одну логическую единицу, которая выполняется либо полностью, либо не выполняется вовсе.

Команды TCL позволяют:

- Подтверждать изменения `(COMMIT)`
- Откатывать транзакции `(ROLLBACK)`
- Создавать точки сохранения `(SAVEPOINT)`
- Удалять точки отката `(RELEASE SAVEPOINT)`
- Настраивать поведение транзакции `(SET TRANSACTION)`

Теперь разберём каждую команду подробно с примерами.

#### 1 BEGIN TRANSACTION или START TRANSACTION – начало транзакции

Перед тем как выполнить несколько связанных операций, необходимо явно начать транзакцию.
Для этого используются две равнозначные команды:

```sql
BEGIN TRANSACTION;
```

или

```sql
START TRANSACTION;
```

Эта команда сообщает базе данных, что все последующие SQL-запросы будут частью одной транзакции.

Пример: Начинаем транзакцию перед переводом денег:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;
```

Теперь все изменения выполняются в рамках одной транзакции, но они ещё не зафиксированы. Если что-то пойдёт не так, можно отменить все изменения, а если всё хорошо – зафиксировать.

#### 2️ COMMIT – подтверждение транзакции

Когда все операции в транзакции выполнены успешно, их нужно зафиксировать в базе данных. Это делается с помощью команды `COMMIT`, которая делает все изменения постоянными.

```sql
COMMIT;
```

После выполнения `COMMIT` изменения невозможно отменить, даже если сервер перезагрузится.

Пример: Завершаем перевод денег и сохраняем изменения:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

COMMIT; -- Подтверждаем изменения
```

Теперь деньги гарантированно переведены, и даже если сервер перезапустится, изменения не пропадут.

### 3️ ROLLBACK – отмена всех изменений

Если во время выполнения транзакции произошла ошибка, можно отменить все изменения, вернув базу в исходное состояние.

Для этого используется команда:

```sql
ROLLBACK;
```

Пример:

Допустим, во время перевода денег на втором шаге произошёл сбой (например, у получателя вообще нет счёта).

Без `ROLLBACK` могли бы возникнуть проблемы:

Деньги списались, но не дошли до получателя → потеря денег!

Используем `ROLLBACK`, чтобы предотвратить это:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

-- Ошибка! Например, счёта 2 не существует
ROLLBACK; -- Все изменения отменяются
```

Теперь баланс на счёте 1 остался неизменным, и никакие деньги не пропали.

#### 4️ SAVEPOINT – создание точки отката

Иногда бывает ситуация, когда нужно отменить не всю транзакцию, а только её часть. Для этого можно использовать `SAVEPOINT` – он создаёт промежуточную точку, до которой можно вернуться.

```sql
SAVEPOINT save1;
```

Если нужно вернуться к этой точке, используется:

```sql
ROLLBACK TO save1;
```

Пример:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

SAVEPOINT step1; -- Создаём точку отката

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

ROLLBACK TO step1; -- Отменяем только вторую операцию

COMMIT; -- Подтверждаем оставшиеся изменения
```

Теперь деньги списались, но не были переведены на второй счёт.

#### 5️ RELEASE SAVEPOINT – удаление точки отката

Если точка сохранения `(SAVEPOINT)` больше не нужна, её можно удалить.

```sql
RELEASE SAVEPOINT save1;
```

После удаления `SAVEPOINT` нельзя откатиться к нему.

Пример:

```sql
START TRANSACTION;

UPDATE accounts 
SET balance = balance - 500 
WHERE account_id = 1;

SAVEPOINT step1; -- Создаём точку отката

UPDATE accounts 
SET balance = balance + 500 
WHERE account_id = 2;

RELEASE SAVEPOINT step1; -- Удаляем точку сохранения

COMMIT; -- Подтверждаем изменения
```

Теперь `step1` больше нельзя использовать для отката.

#### 6️ SET TRANSACTION – настройка параметров транзакции

Иногда требуется изменить поведение транзакции. Для этого используется команда `SET TRANSACTION`.

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

Изоляция транзакции определяет, как параллельные транзакции влияют друг на друга.

## Уровни изоляции в PostgreSQL

В реляционных базах данных транзакции играют ключевую роль в обеспечении целостности данных и управлении многопользовательским доступом. Одна из важных характеристик транзакций — это уровень изоляции. Уровень изоляции определяет, как одна транзакция видит данные, измененные другими транзакциями. SQL стандарт определяет четыре уровня изоляции:

| Уровень изоляции                        | Описание                                                                                                                                                      |
| ------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **READ UNCOMMITTED**                             | Транзакция может видеть изменения других незавершённых транзакций.                                         |
| **READ COMMITTED** *(по умолчанию)* | Транзакция не видит незавершённые изменения других транзакций.                                                 |
| **REPEATABLE READ**                              | Транзакция видит только данные на момент её начала, даже если другие транзакции меняют их. |
| **SERIALIZABLE**                                 | Самый строгий уровень – транзакции выполняются так, как будто они идут одна за другой.         |

**Примеры для каждого уровня изоляции транзакций в PostgreSQL**

##### **1️ READ UNCOMMITTED** – Чтение незавершённых изменений

- Позволяет одной транзакции видеть изменения другой **даже до их `COMMIT`**.
- Может привести к **грязному чтению (dirty read)**, когда данные читаются до окончательного подтверждения.

 **Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
UPDATE products SET price = price + 100 WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
SELECT * FROM products WHERE product_id = 1; -- Покажет цену, даже если транзакция 1 не сделала COMMIT
```

**Опасность:** Если транзакция 1 выполнит `ROLLBACK`, транзакция 2 увидела неверные данные.

**Использование:** Обычно используется, когда важна скорость чтения данных и допустимы потенциальные ошибки.

##### **2️ READ COMMITTED** – Чтение только подтверждённых изменений

Транзакция не видит изменений других транзакций, пока они не зафиксированы `(COMMIT)`. Это уровень по умолчанию в PostgreSQL.

**Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
UPDATE products SET price = price + 100 WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
SELECT * FROM products WHERE product_id = 1; -- Пока не увидит новое значение цены, так как нет COMMIT
```

**Безопасность:** Транзакция 2 никогда не увидит незавершённые изменения.

**Использование:** Является наиболее распространенным уровнем изоляции. Балансирует между целостностью данных и производительностью.

##### **3️ REPEATABLE READ** – Повторяемое чтение

Гарантирует, что в рамках одной транзакции чтение данных не изменится, даже если параллельные транзакции их обновляют. Защищает от фантомных чтений (phantom read), но не предотвращает вставку новых строк.

**Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
SELECT * FROM products WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
UPDATE products SET price = price + 100 WHERE product_id = 1;
COMMIT;

-- Транзакция 1 (повторный запрос)
SELECT * FROM products WHERE product_id = 1; -- Увидит старые данные, так как работает в рамках одного снимка (snapshot)
COMMIT;
```

**Безопасность:** Даже после COMMIT в транзакции 2 транзакция 1 видит данные, которые были на момент её начала.

**Использование:** Используется, когда важно, чтобы данные, прочитанные в начале транзакции, оставались неизменными на протяжении всей транзакции.

##### **4️ SERIALIZABLE** – Полная изоляция транзакций

Самый строгий уровень изоляции. Транзакции выполняются так, как будто они идут одна за другой. Гарантирует полную защиту от фантомных и грязных чтений. Может вызвать конфликты при параллельных изменениях.

**Пример:**

```sql
-- Транзакция 1
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
SELECT * FROM products WHERE product_id = 1;

-- Транзакция 2 (другое подключение)
START TRANSACTION;
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
UPDATE products SET price = price + 100 WHERE product_id = 1;
COMMIT;

-- Транзакция 1 (попытка обновления)
UPDATE products SET price = price + 200 WHERE product_id = 1; 
-- Ошибка: "could not serialize access due to concurrent update"
ROLLBACK;
```

**Опасность:** Если две параллельные транзакции изменяют одну и ту же строку, одна из них будет принудительно откатана (`ROLLBACK`).

**Использование:** Применяется в случаях, когда требуется максимальная целостность данных и изоляция транзакций, несмотря на снижение производительности.

## Backup

![](https://cs14.pikabu.ru/post_img/2021/09/17/7/1631876621194950069.jpg)

> Есть два типа людей:
> – те, кто делает бэкапы,
> – и те, кто еще не плакал.
>
> © Админская мудрость

### Зачем нужен backup?

`Резервное копирование` — это процесс создания копии данных, которую можно использовать для восстановления базы данных в случае потери данных или повреждения. Основные причины, по которым необходимо делать резервные копии:

1. **Защита от потери данных**: Аппаратные сбои, ошибки пользователей, атаки вирусов и хакеров могут привести к потере данных.
2. **Восстановление после сбоев**: Возможность быстро восстановить работоспособность базы данных после сбоя.
3. **Исторические данные**: Возможность доступа к старым версиям данных для анализа или аудита.
4. **Разработка и тестирование**: Копии данных могут использоваться для разработки, тестирования и экспериментов без риска повреждения основной базы данных.

### pg_dump

`pg_dump` — это утилита для создания резервных копий базы данных PostgreSQL. Она позволяет экспортировать данные и схему базы данных в файл.

#### Основные функции и параметры pg_dump

1. **Экспорт всей базы данных:**

   ```sh
   pg_dump -U username -h hostname -d dbname > backup.sql
   ```

   Параметры:

   - `-U`: имя пользователя.
   - `-h`: хост, на котором работает база данных.
   - `-d`: имя базы данных.
2. **Экспорт в формат tar или custom:**

   ```sh
   pg_dump -U username -h hostname -d dbname -F t > backup.tar
   ```

   Параметр `-F` указывает формат резервной копии:

   - `p`: plain текст (по умолчанию).
   - `c`: custom.
   - `t`: tar.
3. **Экспорт конкретной таблицы:**

   ```sh
   pg_dump -U username -h hostname -d dbname -t tablename > table_backup.sql
   ```

   Параметр `-t` указывает таблицу для экспорта.
4. **Сжатие резервной копии:**

   ```sh
   pg_dump -U username -h hostname -d dbname | gzip > backup.sql.gz
   ```

#### Примеры использования

- Экспорт всей базы данных с указанием формата:

  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -F c > mydatabase.backup
  ```
- Экспорт схемы без данных:

  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -s > schema_only.sql
  ```
- Экспорт данных без схемы:

  ```sh
  pg_dump -U postgres -h localhost -d mydatabase -a > data_only.sql
  ```

### pg_restore

`pg_restore` — это утилита для восстановления базы данных из резервной копии, созданной с помощью `pg_dump` в формате tar или custom.

#### Основные функции и параметры pg_restore

1. **Восстановление базы данных:**

   ```sh
   pg_restore -U username -h hostname -d dbname backup_file
   ```
2. **Создание новой базы данных и восстановление:**

   ```sh
   createdb -U username -h hostname new_dbname
   pg_restore -U username -h hostname -d new_dbname backup_file
   ```
3. **Восстановление только схемы:**

   ```sh
   pg_restore -U username -h hostname -d dbname -s backup_file
   ```
4. **Восстановление только данных:**

   ```sh
   pg_restore -U username -h hostname -d dbname -a backup_file
   ```

#### Примеры использования

- Восстановление базы данных из tar-архива:

  ```sh
  pg_restore -U postgres -h localhost -d mydatabase mydatabase.backup
  ```
- Восстановление с применением дополнительных параметров:

  ```sh
  pg_restore -U postgres -h localhost -d mydatabase -j 4 --verbose mydatabase.backup
  ```

  Параметр `-j` указывает количество параллельных потоков для ускорения процесса восстановления.

### Практические советы

1. **Планирование резервного копирования:** Регулярно выполняйте резервное копирование базы данных, особенно перед внесением значительных изменений.
2. **Проверка резервных копий:** Периодически проверяйте резервные копии, чтобы убедиться, что они корректно восстанавливаются.
3. **Автоматизация:** Настройте автоматическое резервное копирование с помощью cron или других планировщиков задач.
4. **Безопасность:** Храните резервные копии в безопасных местах и защищайте их паролями или шифрованием.
5. **Документация:** Ведите документацию по процессу резервного копирования и восстановления, чтобы упростить обучение новых сотрудников и улучшить управляемость.

> Использование `pg_dump` и `pg_restore` позволяет эффективно управлять резервными копиями и восстанавливать данные в PostgreSQL. Эти утилиты предоставляют гибкость и надежность, необходимые для обеспечения безопасности и доступности данных. Регулярное резервное копирование и проверка его целостности — залог стабильной работы любой системы управления базами данных.

### Примеры использования

1. **Регулярное резервное копирование**: В крупных компаниях, где потеря данных может привести к серьезным финансовым потерям, резервное копирование проводится ежедневно.
2. **Восстановление после сбоя**: Если база данных повреждена из-за сбоя оборудования, можно быстро восстановить данные из последнего бэкапа.
3. **Создание тестовых сред**: Разработчики могут использовать резервные копии для создания тестовых баз данных, что позволяет тестировать новые функции без риска для основной базы.

> Резервное копирование и восстановление — это критически важные процессы для обеспечения безопасности данных в PostgreSQL. Понимание различных методов резервного копирования и восстановления поможет вам эффективно управлять базами данных и минимизировать риски потери данных. Спасибо за внимание!
