# Лекция 20. Virtual env. Pip. Устанавливаемые модули. Pyenv.

![virtual_python.webp](image/virtual_python.webp)

## Virtualenv и venv – Изоляция окружения в Python

**Виртуальное окружение (virtual environment)** – это изолированная копия Python, в которой можно устанавливать свои библиотеки, не затрагивая систему. 

Когда мы пишем программы на Python, нам часто приходится использовать внешние библиотеки (например, `Django`, `Flask`, `requests`). Но что если два разных проекта требуют разные версии одной и той же библиотеки? 

Допустим, у нас есть два проекта:

- Проект 1 – это веб-приложение, написанное на `Django 3.2`.
- Проект 2 – новый сайт, который требует `Django 4.1`.

Если мы установим `Django 4.1` глобально, то `Проект 1` перестанет работать, потому что его код не поддерживает новую версию `Django`. Такую проблему называют **"конфликт версий библиотек"**.

### Как решить проблему?

Решение – использовать виртуальные окружения!

Виртуальное окружение – это специальная папка, в которой хранятся:

- 1️ Своя версия Python
- 2️ Свои установленные библиотеки
- 3️ Свои зависимости (requirements.txt)

Каждый проект получает своё изолированное окружение, где можно устанавливать свои версии библиотек, и это никак не влияет на другие проекты или на глобальную систему Python.

### Как это выглядит на практике?

Представим, что у нас есть два проекта:

**Мой проект 1 (Django 3.2)**

```plaintext
/my_project_1
  ├── venv/  ← Виртуальное окружение для проекта 1
  ├── app.py
  ├── requirements.txt
```
**Мой проект 2 (Django 4.1)**

```plaintext
/my_project_2
  ├── venv/  ← Виртуальное окружение для проекта 2
  ├── main.py
  ├── requirements.txt
```

В каждом проекте в папке `venv/ `хранится отдельный Python и свои библиотеки. Теперь мы можем запустить Проект 1 с `Django 3.2` и Проект 2 с `Django 4.1` без конфликтов.

Результат:

`Django 3.2` в `my_project_1` и `Django 4.1` в `my_project_2` работают одновременно!

![virtual_env.png](image/virtual_env.png)

### Venv

**venv** – встроенное средство создания окружения. Начиная с `Python 3.3` в стандартную библиотеку добавлен модуль `venv`. Это рекомендованный способ создания виртуального окружения.

**Как создать виртуальное окружение в venv?**

Перейдём в папку проекта или создамим одну папку на компьютере под все виртуальные окружения например: `virtual environments`. Тут все зависит от того как вам удобнее, оба варианта правильные! После находясь в нужной папке нам нужно выполнить команду: 

```bash
python -m venv myenv
```

#### Что происходит?

Создаётся папка `myenv/`, в которой хранятся:

- Собственная копия интерпретатора Python.
- Отдельная директория для установленных пакетов.
- Файлы конфигурации окружения.

**Что находится внутри myenv/?**

Если мы заглянем внутрь `myenv/`, то увидим следующую структуру:

```plaintext
myenv/
│── bin/ (Scripts/ в Windows)
│── include/                   
│── lib/                       
│── pyvenv.cfg                 
```

- **bin/Scripts:** Содержит скрипты для активации/деактивации окружения и сам интерпретатор Python.
- **lib/Lib:** Содержит установленные пакеты и зависимости.
- **include:** Содержит файлы заголовков C, если они требуются для пакетов.
- **pyvenv.cfg:** Конфигурационный файл, содержащий информацию о виртуальном окружении.

### Как активировать окружение?

При активации виртуального окружения происходит изменение переменных окружения:

- **Изменение PATH:** Путь к исполняемым файлам виртуального окружения добавляется в начало переменной `PATH`. Это обеспечивает приоритет использования интерпретатора и скриптов из виртуального окружения.
- **Установка переменных окружения:** Устанавливаются специфические переменные окружения, такие как `VIRTUAL_ENV`, указывающая на путь к активному виртуальному окружению.

**Windows (cmd, PowerShell):**

```bash
myenv\Scripts\activate
```

**Mac/Linux (bash, zsh, fish):**

```bash
source myenv/bin/activate
```
После активации в терминале появится `(myenv)` – это значит, что теперь все пакеты будут устанавливаться только внутри myenv.

![my_env.png](image/my_env.png)
