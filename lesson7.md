# Лекция 7. Функции, типизация, lambda. Map, zip, filter.

## Функции в Python

**Функция** — это именованный блок кода, который можно многократно использовать в разных местах программы. Они позволяют разбивать код на логические части, делают его более читаемым, удобным для тестирования и сопровождения.

### Зачем нужны функции?

- Повторное использование кода – не нужно копировать один и тот же код, можно просто вызвать функцию.
- Упрощение структуры программы – код становится понятнее и логичнее.
- Удобство отладки – если код вынесен в функцию, проще найти и исправить ошибку.
- Масштабируемость – при разработке больших проектов удобно делить код на отдельные блоки.

### Объявление функций

![function.jpg](image/function.jpg)

В Python для создания функции используется ключевое слово `def`, после которого указывается имя функции и круглые скобки с параметрами (если они есть).

**Простейший пример функции**

```python
def greet():
    print("Привет, Python!")
    
greet()  # Вызов функции

#Привет, Python!
```
**Разбор кода:**

`def greet():` – создаём функцию с именем greet, которая ничего не принимает.
`print("Привет, Python!")` – тело функции, выполняется при её вызове.
`greet()` – вызов функции.

### Функции с параметрами

Функция может принимать параметры, что делает её более гибкой.

**Пример с аргументами**

```python
def greet(name):
    print(f"Привет, {name}!")

greet("Алиса")
greet("Боб")
```

**Как это работает?**

`name` – параметр функции, который передаётся при вызове.
`greet("Алиса")` – вызов с аргументом "Алиса", внутри функции `name` = "Алиса", и выполняется `print(f"Привет, {name}!")`.

### Функции с несколькими параметрами

Можно передавать несколько аргументов.

Пример:

```python

def add(a, b):
    print(a + b)

add(3, 7)  # 10
add(15, 5)  # 20
```

### Значения по умолчанию

Если аргумент не передан, можно задать значение по умолчанию.

```python
def greet(name="Гость"):
    print(f"Привет, {name}!")

greet("Алиса")  # Привет, Алиса!
greet()         # Привет, Гость!
```

Если аргумент не указан, Python использует значение "Гость".

### Функции с возвращаемым значением

Иногда нужно, чтобы функция возвращала результат вместо того, чтобы сразу его выводить. Для этого используется `return`.

Пример функции с `return`:

```python
def square(number):
    return number ** 2

result = square(5)  # Функция вернет 5 ** 2 = 25
print(result)
```

**Объяснение:**

- `square(5)` – вычислит 5 ** 2 и вернёт 25.
- `result = square(5)` – сохраняем результат в переменную.
- `print(result)` – выводим результат.

**Важно: после return функция завершается, и код после него не выполняется.**

> Функции у которых явно не указан `return` будут интерпретироваться питоном как функция в которой последней инструкцией
> написано `return None`, потому что у функции всегда должно быть возвращаемое значение.

### Область видимости переменных

В Python переменные могут быть локальными и глобальными.

**Локальная переменная**

Переменная, объявленная внутри функции, видна только внутри этой функции.

```python
def example():
    x = 10  # Локальная переменная
    print(x)

example()
print(x)  # Ошибка! x не существует за пределами функции
```

**Глобальная переменная**

Переменная, объявленная вне функции, доступна везде.

```python
x = 5  # Глобальная переменная

def example():
    print(x)  # Используем глобальную переменную

example()  # 5
```

### Типизация и аннотации

Python - это язык с динамической типизацией, что означает, что типы переменных определяются автоматически во время выполнения программы. Однако, начиная с версии Python 3.5, можно использовать аннотации типов для объявления ожидаемых типов аргументов и возвращаемых значений функции. Это делает код более читаемым и помогает IDE и инструментам статического анализа проводить проверку типов. Например:

```python
def add(x: int, y: int) -> int:  # Стрелка это два символа "-" и ">"
    result = x + y
    return result
```

Типы данных указывать в python не обязательно, но в современном мире, код без типизаций считается моветоном, на серьезных проектах все и всегда будет покрыто типизациями.

Здесь мы аннотировали аргументы x и y как `int`, а возвращаемое значение как `int`.

Через двоеточие указывается тип данных для каждого передаваемого аргумента, а за скобками через стрелку, указывается какой тип данных возвращает наша функция.

### Передача случайного количества параметров

Python предоставляет мощные механизмы для работы с аргументами в функциях. Два из них — `*args` и `**kwargs`. Они позволяют передавать произвольное количество аргументов в функции, делая код более гибким и универсальным. `args` используется для передачи не именованных параметров, а `kwargs` для передачи именованных.

#### `*args`: передача произвольного количества позиционных аргументов
Если перед именем параметра функции поставить *, то все переданные аргументы будут собраны в кортеж.

**Основной синтаксис**

```python
def print_args(*args):
    print(args)

print_args(1, 2, 3, "hello")  
# Выведет: (1, 2, 3, 'hello')
```

**Как это работает?**

`*args` собирает все переданные аргументы в кортеж(`tuple()`).
В примере выше `args` = (1, 2, 3, "hello").

#### Использование *args в цикле

```python
def print_each(*args):
    for arg in args:
        print(arg)

print_each("Python", "is", "awesome!")
#Python
#is
#awesome!
```
#### Применение `*args` в вычислениях

```python
def multiply(*numbers):
    result = 1
    for num in numbers:
        result *= num
    return result

print(multiply(2, 3, 4))  # 24 (2 * 3 * 4)
```

**Что здесь происходит?**

Функция `multiply` принимает любое количество чисел. Перемножает их и возвращает результат.

#### **kwargs: передача именованных аргументов

Если перед именем параметра функции поставить **, то все именованные аргументы будут собраны в словарь.

**Основной синтаксис**

```python
def print_kwargs(**kwargs):
    print(kwargs)

print_kwargs(name="Alice", age=25, city="New York")
#{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

**Как это работает?**

`**kwargs` собирает все переданные именованные аргументы в словарь.

В примере выше `kwargs` = {'name': 'Alice', 'age': 25, 'city': 'New York'}.

#### Использование `**kwargs` в цикле
```python
def print_user_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_user_info(name="John", age=30, country="USA")

#name: John
#age: 30
#country: USA
```

#### Применение `**kwargs` в функции с настройками
```python
def configure_settings(**kwargs):
    default_settings = {
        "theme": "light",
        "language": "English",
        "notifications": True
    }
    default_settings.update(kwargs)
    return default_settings

print(configure_settings(language="French", notifications=False))

#{'theme': 'light', 'language': 'French', 'notifications': False}
```

Если переданы дополнительные параметры, они перезапишут стандартные значения.

### Комбинированное использование *args и **kwargs

Вы можете использовать оба механизма одновременно. Главное правило:

***args должно идти перед **kwargs.**

```python
def print_all(arg1, *args, kwarg1="default", **kwargs):
    print("Обязательный аргумент:", arg1)
    print("Дополнительные аргументы (*args):", args)
    print("Именованный аргумент (kwarg1):", kwarg1)
    print("Дополнительные именованные аргументы (**kwargs):", kwargs)

print_all("first", "second", "third", kwarg1="custom", key1="value1", key2="value2")
```

**Вывод:**

```bash
Обязательный аргумент: first
Дополнительные аргументы (*args): ('second', 'third')
Именованный аргумент (kwarg1): custom
Дополнительные именованные аргументы (**kwargs): {'key1': 'value1', 'key2': 'value2'}
```

### Распаковка коллекций с * и **

Python позволяет распаковывать списки, кортежи и словари при передаче в функцию.

#### Распаковка кортежей и списков с *

```python
def multiply(a, b):
    return a * b

values = (3, 4)
print(multiply(*values))  # Распаковка кортежа → multiply(3, 4)
```

```python
numbers = [1, 2, 3]
print(sum(*numbers))  # sum(1, 2, 3)
```

Распаковка с использованием * может быть полезной, когда вам нужно передать переменное количество аргументов функции или когда вы работаете с данными, хранящимися в кортежах или списках. Это делает ваш код более гибким и читаемым.

#### Распаковка словарей с **

```python
def print_person(name, age):
    print(f"{name} is {age} years old.")

person = {"name": "Alice", "age": 30}
print_person(**person)  # print_person(name="Alice", age=30)
```

#### Комбинированная распаковка

```python
def print_all(*args, **kwargs):
    print("Args:", args)
    print("Kwargs:", kwargs)

values = (1, 2, 3)
info = {"name": "Alice", "age": 30}
print_all(*values, **info)

#Args: (1, 2, 3)
#Kwargs: {'name': 'Alice', 'age': 30}
```

Распаковка с использованием ** может быть полезной, когда вам нужно передавать переменное количество именованных аргументов функции или когда вы работаете с данными, хранящимися в словарях. Это делает ваш код более гибким и удобным для работы с разными видами данных.

### Передача изменяемых типов данных в Python

Как говорилось ранее Python поддерживает два типа данных: изменяемые `(mutable)` и неизменяемые `(immutable)`. Это ключевое различие влияет на способ передачи данных в функции, а также на поведение программ.

**Изменяемые и неизменяемые типы данных:**

| **Неизменяемые (Immutable)** | **Изменяемые (Mutable)** |
|------------------------------|--------------------------|
| Числа (int, float, complex)  | Списки (list)           |
| Строки (str)                 | Множества (set)         |
| Кортежи (tuple)              | Словари (dict)          |
| Булевы значения (bool)       | Объекты классов (если они изменяемые) |


- Неизменяемые типы данных – их нельзя изменить после создания. Если попытаться изменить, создаётся новый объект.
- Изменяемые типы данных – позволяют менять свое содержимое без изменения ссылки в памяти.

#### Передача данных по ссылке и по значению
В Python все переменные хранят ссылки на объекты в памяти. Однако передача их в функции может работать по-разному в зависимости от типа данных.

**Передача по значению**

Когда мы передаем неизменяемый объект (число, строку, кортеж) в функцию, передается копия объекта, а не сам объект.

```python
def modify_number(x):
    x += 10  # Создаётся новый объект
    print("Внутри функции:", x)

num = 5
modify_number(num)
print("Вне функции:", num)

#Внутри функции: 15
#Вне функции: 5
```

**Объяснение**: x += 10 создаёт новый объект, а переменная num остается неизменной.

Передача по ссылке
Когда передается изменяемый объект (список, словарь, множество), передается ссылка на объект в памяти, а не его копия. Это значит, что изменение внутри функции отразится на исходном объекте.

```python
def modify_list(lst):
    lst.append(4)  # Изменение исходного списка
    print("Внутри функции:", lst)

my_list = [1, 2, 3]
modify_list(my_list)
print("Вне функции:", my_list)

#Внутри функции: [1, 2, 3, 4]
#Вне функции: [1, 2, 3, 4]
```
**Объяснение:** Список `my_list` изменился, потому что передавался по ссылке.

#### Как избежать изменения исходных данных?

Если нам необходимо защитить исходные данные, можно передавать копию изменяемого объекта.

**Создание поверхностной копии**

```python
def modify_list_copy(lst):
    new_list = lst.copy()  # Создаётся поверхностная копия
    new_list.append(4)
    print("Внутри функции:", new_list)

original_list = [1, 2, 3]
modify_list_copy(original_list)
print("Вне функции:", original_list)

#Внутри функции: [1, 2, 3, 4]
#Вне функции: [1, 2, 3]
```

**Объяснение:** lst.copy() создает новый список, поэтому оригинал остается неизменным.

#### Создание глубокой копии

Если в списке есть вложенные объекты, используем `copy.deepcopy()`.

```python
import copy

def modify_nested_list(lst):
    new_list = copy.deepcopy(lst)  # Глубокая копия
    new_list[1].append(99)
    print("Внутри функции:", new_list)

original_list = [1, [2, 3], 4]
modify_nested_list(original_list)
print("Вне функции:", original_list)

#Внутри функции: [1, [2, 3, 99], 4]
#Вне функции: [1, [2, 3], 4]
```

**Объяснение:** `copy.deepcopy()` копирует все вложенные объекты, поэтому изменения не затрагивают оригинальный список.

### Анонимные функции (lambda)

**Лямбда-функции (или анонимные функции)**- это специальный вид функций, которые могут быть определены в одной строке без использования ключевого слова `def`. Они часто используются для создания коротких функций, которые передаются в качестве аргументов другим функциям. Например:

```python
square = lambda x: x ** 2
print(square(5))  # Выведет 25
```

Лямбда-функции полезны, когда требуется передать небольшую функцию в функцию высшего порядка, такую как map, `filter` или `sorted`.
Те же примеры для `map` и `filter` в реальности выглядели бы вот так:

**map:**

```python
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x**2, numbers))
print(squared_numbers)  # Выведет [1, 4, 9, 16, 25]
```

**filter:**

```python
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # Выведет [2, 4, 6]
```

## Функции Map, Zip, Filter в Python

В Python есть несколько встроенных функций, которые позволяют эффективно работать с последовательностями, применяя к ним различные операции. Среди них `map()`, `zip()` и `filter()`. Эти функции позволяют писать более краткий, удобочитаемый и эффективный код, избавляя от необходимости писать длинные циклы.

### Функция map()

Функция `map()` используется для применения заданной функции ко всем элементам итерируемого объекта (например, списка или кортежа). В результате возвращается итератор с преобразованными значениями.

Синтаксис:

```python
map(function, iterable)
```

- `function` — функция, которая применяется к каждому элементу последовательности.
- `iterable` — последовательность, элементы которой обрабатываются.

**Примеры использования `map()`**

Применение функции `map()` к списку чисел:

```python
def square(num):
    return num ** 2

numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(square, numbers))
print(squared_numbers)  # [1, 4, 9, 16, 25]
```

Использование `lambda` внутри `map()` (анонимная функция):

```python
numbers = [1, 2, 3, 4, 5]
squared_numbers = list(map(lambda x: x ** 2, numbers))
print(squared_numbers)  # [1, 4, 9, 16, 25]
```

**Применение `map()` к строкам:**

```python
words = ["hello", "world", "python"]
upper_words = list(map(str.upper, words))
print(upper_words)  # ['HELLO', 'WORLD', 'PYTHON']
```

### Функция zip()

Функция `zip()` используется для объединения нескольких последовательностей (списков, кортежей и т. д.) в один итератор кортежей. Количество элементов в результирующем объекте будет равно длине самой короткой переданной последовательности.

**Синтаксис:**

```python
zip(iterable1, iterable2, ...)
```

`iterable1`, `iterable2`, ... — последовательности, которые нужно объединить.

**Примеры использования `zip()`**

Объединение двух списков в пары:

```python
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]
combined = list(zip(names, ages))
print(combined)  # [('Alice', 25), ('Bob', 30), ('Charlie', 35)]
```

**Использование `zip()` в цикле:**

```python
names = ["Alice", "Bob", "Charlie"]
ages = [25, 30, 35]

for name, age in zip(names, ages):
    print(f"{name} is {age} years old.")

#Alice is 25 years old.  
#Bob is 30 years old.  
#Charlie is 35 years old.  
```

**Распаковка `zip()` обратно в списки:**

```python
zipped_data = [('Alice', 25), ('Bob', 30), ('Charlie', 35)]
names, ages = zip(*zipped_data)

print(list(names))  # ['Alice', 'Bob', 'Charlie']
print(list(ages))   # [25, 30, 35]
```

### Функция filter()

Функция `filter()` используется для фильтрации элементов последовательности на основе заданного условия (функции). Она возвращает только те элементы, для которых функция возвращает `True`.

**Синтаксис:**

```python
filter(function, iterable)
```

- `function` — функция, которая возвращает `True` или `False` для каждого элемента последовательности.
- `iterable` — последовательность, элементы которой фильтруются.

**Примеры использования `filter()`**

Фильтрация четных чисел из списка:

```python
def is_even(num):
    return num % 2 == 0

numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(is_even, numbers))
print(even_numbers)  # [2, 4, 6]
```

**Использование `lambda` внутри `filter()`:**

```python
numbers = [1, 2, 3, 4, 5, 6]
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))
print(even_numbers)  # [2, 4, 6]
```

**Фильтрация строк по длине:**

```python
words = ["apple", "cat", "banana", "dog", "elephant"]
long_words = list(filter(lambda word: len(word) > 3, words))
print(long_words)  # ['apple', 'banana', 'elephant']
```

#### Практические задания

1. Напишите функцию `greet(name)`, которая принимает имя пользователя и возвращает строку "Привет, `{name}`!".

2. Создайте функцию `add(a, b)`, которая принимает два числа и возвращает их сумму.

3. Реализуйте функцию `is_even(n)`, которая принимает число и возвращает True, если оно четное, иначе `False`.

4. Напишите функцию `factorial(n)`, которая принимает число n и возвращает его факториал (без рекурсии).

5. Создайте функцию `find_max(a, b, c)`, которая принимает три числа и возвращает наибольшее из них.

6. Реализуйте функцию `power(base, exp)`, которая принимает два аргумента: base (основание) и exp (показатель степени) и возвращает base возведенное в степень exp.

7. Создайте функцию `average(*numbers)`, которая принимает любое количество чисел и возвращает их среднее значение.

8. Напишите функцию `is_palindrome(word)`, которая проверяет, является ли переданное слово палиндромом.

9. Создайте функцию `count_vowels(text)`, которая принимает строку и возвращает количество гласных букв в ней.

10. Реализуйте функцию `is_fibonacci(n)`, которая проверяет, является ли число n числом Фибоначчи.

11. Напишите функцию `squares(n)`, которая принимает число n и возвращает список квадратов чисел от 1 до n.

12. Создайте функцию `filter_even(numbers)`, которая принимает список чисел и возвращает новый список, содержащий только четные числа.

13. Реализуйте функцию `convert_temperature(temp, scale)`, которая принимает температуру и шкалу ('C' или 'F') и конвертирует её в другую систему измерения.

14. Создайте функцию `sum_numbers(*args)`, которая принимает любое количество аргументов и возвращает их сумму.

15. Напишите функцию `print_person_info(**kwargs)`, которая принимает именованные аргументы (name, age, city) и выводит информацию о человеке.