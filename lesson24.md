# Лекция 24. Модели в Django. Установка и настройка базы данных PostgreSQL. Связи между моделями. Meta, Abstract, Proxy

![](image/Models_in_Django.jpg)

## Введение

Когда мы начинаем работать с `Django`, по умолчанию проект использует `SQLite` — это очень простая база данных, которая хранится в одном файле. Она удобна для учебных проектов и быстрого старта. Но как только мы начинаем строить что-то серьёзное — блог, интернет-магазин, корпоративную систему — `SQLite` становится слишком «маленькой» и ограниченной.

Вот тут-то на сцену выходит `PostgreSQL`.

Почему стоит использовать именно PostgreSQL?

- Надёжность — `PostgreSQL` используется многими крупными компаниями, и она считается одной из самых стабильных баз данных.
- Скорость и масштабируемость — когда у вас не 10, а 10 000 записей, `PostgreSQL` работает уверенно и быстро.
- Умная работа с данными — `PostgreSQL` умеет хранить не только таблицы, но и такие вещи как массивы, `JSON`, даты и даже географические координаты.
- Удобство для Django — Django "любит" `PostgreSQL`, потому что с ней работают все фишки фреймворка: поиск по `JSON`, кастомные типы полей и индексы.
- Гибкость и настройка — можно легко подключаться с разных устройств, создавать пользователей с разными правами и безопасно управлять данными.

Всё это делает `PostgreSQL` лучшим выбором для разработки на `Django`, особенно если проект планируется серьёзный и «на вырост».

## Что мы будем учить?

![](image/MVT_Model.png)

## Установка PostgreSQL

К этому моменту у вас уже должен быть установлен `PostgreSQL`. Если нет, то установите его. Инструкции по установке можно найти [тут](https://github.com/fullt1lt/CoursesPython/blob/main/postgres_installation.md) или [на сайте PostgreSQL](https://www.postgresql.org/download/).

## Создание базы данных и пользователя PostgreSQL.

Для начала зайдем в консоль нашей БД. Для этого откройте терминал и выполните следующие команды:

Для Windows:

```shell
psql -U postgres
```

Для Linux И MacOS:

```bash
sudo -u postgres psql
```

После этого введите пароль от пользователя `postgres`, который вы устанавливали при установке `PostgreSQL`. Если вы всё сделали правильно, то вы увидите что-то вроде этого:

![](image/postgress.png)

Если нет значит вы что-то сделали не так. Проверьте, правильно ли вы установили `PostgreSQL` и правильно ли указали пароль.

### Создание базы данных

Для создания базы данных в `PostgreSQL` используется команда `CREATE DATABASE`. Например, чтобы создать базу данных с именем `mydatabase` и кодировкой `UTF8`, выполните следующую команду:

```psql
CREATE DATABASE mydatabase WITH ENCODING 'UTF8';
```

После этого вы можете проверить, что база данных была создана, выполнив команду:

```psql
\с mydatabase;
```

Следющий шаг — создание пользователя. Для этого выполните следующую команду:

```psql
CREATE USER myuser WITH PASSWORD 'mypassword';
```

Замените `myuser` и `mypassword` на желаемые имя пользователя и пароль. **Важно придумать надежный пароль, особенно в реальных проектах.**

После этого дадим пользователю права на созданную базу данных:

```psql
GRANT ALL PRIVILEGES ON DATABASE mydatabase TO myuser;
```

Пример как это должно выглядеть:

![](image/models_psql.png)

Если вы используете Postgres 15 и новее. Необходимо выполнить дополнительное действие после предоставления прав к базе данных. Нужно предоставить вашему пользователю права к схеме `public` в новой базе данных.

Для этого нужно подключиться к новой базе если вы еще не подключились:

```psql
\c mydatabase;
```

Где `mydatabase` — это имя вашей базы данных.

И выполнить следующую команду:

```psql
GRANT ALL PRIVILEGES ON SCHEMA public TO myuser;
```

Теперь у вас есть база данных и пользователь, который может к ней подключаться. Вы можете выйти из консоли `PostgreSQL`, выполнив команду:

```psql
\q
```

Но я рекумендую вам оставить консоль открытой, так как мы будем использовать её в дальнейшем, когда будем заполнять файл `settings.py`.

### Установка psycopg:

Чтобы Django мог подключаться к PostgreSQL, ему нужен специальный драйвер. Самый популярный и официальный — это `psycopg` (в новой версии он называется `psycopg` вместо `psycopg2`).
Самое главное, не забываем что `psycopg` должен быть установлен в виртуальном окружении, в котором вы работаете с проектом `Django`. Инструкция [ТУТ](https://github.com/fullt1lt/CoursesPython/blob/main/lesson20.md): 

**Windows (cmd, PowerShell):**

```bash
myenv\Scripts\activate
```

Если вы используете Git Bash в Windows или VsCode, то используйте:

```bash
source myenv/Scripts/activate
```

**Mac/Linux (bash, zsh, fish):**

```bash
source myenv/bin/activate
```
После активации в терминале появится `(myenv)` – это значит, что теперь все пакеты будут устанавливаться только внутри `myenv`.

```bash
pip install psycopg
```

Если всё установилось — можно переходить к конфигурации `Django`.

### Настройка Django

Теперь откройте файл `settings.py` вашего проекта и найдите секцию `DATABASES`. Она должна выглядеть примерно так:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / "db.sqlite3",
    }
}
```

Мы будем использовать `PostgreSQL`, поэтому изменим эту секцию на:

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydatabase',           # Имя вашей базы данных
        'USER': 'myuser',         # Имя пользователя
        'PASSWORD': 'mypassword', # Пароль пользователя
        'HOST': 'localhost',      # Хост (обычно localhost)
        'PORT': '5432',           # Порт PostgreSQL (по умолчанию 5432)
    }
}
```

Убедитесь, что вы используете правильные значения для вашей БД, пользователя и пароля.

Теперь, чтобы проверить, что всё работает, запустите сервер `Django`:

```bash
python manage.py runserver
```

Если все быдло сделано правильно, то вы увидите сообщение о том, что сервер запущен и работает:

![](image/Django_console_before_bd.png)

**Обратите внимание, что в терминале вы можете увидеть предупреждение:**

Когда мы запускаем сервер через `python manage.py runserver`, `Django` сначала делает системную проверку — чтобы убедиться, что всё настроено правильно. И вот здесь мы получили предупреждение:

`You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.`

#### Что это значит?

Когда мы только начинаем проект Django, он уже содержит встроенные приложения:

- `admin` — админ-панель
- `auth` — система авторизации
- `sessions` — работа с сессиями пользователей
- `contenttypes` — поддержка различных типов контента

Эти приложения уже готовы к использованию, но... в базе данных для них пока ничего нет. То есть `Django` говорит: *«У меня есть инструкции, какие таблицы нужны этим приложениям, но я их ещё не создал в базе данных!»*

#### Что такое миграции в Django?

Миграции — это инструкции, по которым Django создаёт таблицы в базе данных. Можно представить их как чертежи или планы строительства:

- Сначала мы описываем модель (класс) в `models.py`, где указываем, какие поля будут в таблице, их типы и связи между ними. 
- `Django` на основе этих моделей создаёт файл миграции — в нём прописано, какие поля будут в таблице, как они называются, какие у них типы и связи
- Затем мы применяем миграции, и Django по этим чертежам строит настоящие таблицы в базе данных

#### Применение миграций — команда migrate

Теперь, когда `Django` нас предупредил, что есть неприменённые миграции, самое время их применить. Делается это очень просто:

```bash
python manage.py migrate
```

**Что делает эта команда?**

- Django считывает все файлы миграций (встроенные и созданные тобой).
- Затем он создаёт в базе данных таблицы, описанные в этих миграциях.
- А в специальной служебной таблице (django_migrations) запоминает, что именно уже применено.

**Результат выполнения:**

После запуска команды migrate, в терминале ты увидишь список операций, которые Django проделал:

![](image/Django_migrate.png)

**Важно:**

**Мы делаем это один раз при первом запуске проекта или каждый раз, когда появляются новые миграции (например, после создания новых моделей).**

Также если в настройках `settings.py` у вас не указано ваше приложение, то команда `migrate` не будет работать. Поэтому убедитесь, что в `settings.py` у вас указано ваше приложение:

```python
INSTALLED_APPS = [
    "django.contrib.admin",
    "django.contrib.auth",
    "django.contrib.contenttypes",
    "django.contrib.sessions",
    "django.contrib.messages",
    "django.contrib.staticfiles",
    "my_app" <-- ваше приложение, которое вы создали ранее
]
```

Теперь, когда все миграции применены, база данных настроена, и можно переходить к созданию собственных моделей в Django!

### Что такое модели Django?

`Модель в Django `— это обычный Python-класс, который наследуется от `django.db.models.Model` и представляет одну таблицу в базе данных. Каждый атрибут класса — это столбец (поле) в таблице.

Проще говоря: `модель → таблица`, `атрибут модели → столбец таблицы`.

Полную документацию по моделям можно найти [тут](https://docs.djangoproject.com/en/4.2/topics/db/models/).

#### Где хранится модель?

По умолчанию модели хранятся в файле `models.py` внутри приложения. Например, если у вас есть приложение `myapp`, то файл будет находиться по пути `myapp/models.py`.

Например, структура проекта будет такая:

```plaintext
my_project/
└── my_app/
    ├── models.py ← вот тут и будут наши модели
    └── ...
```

**После всех настроек, создания базы данных и применения миграций, мы можем создать свою первую модель!!!**

## Первая модель в Django

Перейдите в файл `models.py` вашего приложения и создайте свою первую модель. Например, давайте создадим модель `Product` (товар) для интернет-магазина:

```python
from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=100)  # Название продукта
    price = models.DecimalField(max_digits=10, decimal_places=2)  # Цена
```

Мы создадим модель, которая будет описывать товар в интернет-магазине (или в любой другой системе учёта). Она будет содержать всего два поля:

- `name` – название товара
- `price` – цена товара

Но есть важный момент...Когда мы пишем модель, мы можем не указывать поле `id`. `Django` создаёт его автоматически. Это будет целое число `(IntegerField)` с автоинкрементом — то есть оно будет увеличиваться на 1 с каждой новой записью.

Хотя мы явно указали только два поля — `name` и `price`, Django "под капотом" добавляет третий столбец:

```sql
id INTEGER PRIMARY KEY AUTOINCREMENT
```

После того, как вы создали модель, вам нужно создать миграцию для неё. Это делается с помощью команды:

```bash
python manage.py makemigrations
```

Если всё в порядке, ты увидишь примерно такое сообщение:

```bash
Migrations for 'my_app':
  my_app/migrations/0001_initial.py
    - Create model Product
```

Теперь `Django` создал файл миграции — это `Python-файл`, в котором описано, какую таблицу и поля нужно создать.

Он будет находиться в папке `migrations` вашего приложения. Например, если у вас приложение `my_app`, то файл будет находиться по пути `my_app/migrations/0001_initial.py`. И выглядеть примерно так:

```python
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = []

    operations = [
        migrations.CreateModel(
            name="Product",
            fields=[
                (
                    "id",
                    models.BigAutoField(
                        auto_created=True,
                        primary_key=True,
                        serialize=False,
                        verbose_name="ID",
                    ),
                ),
                ("name", models.CharField(max_length=100)),
                ("price", models.DecimalField(decimal_places=2, max_digits=10)),
            ],
        ),
    ]
```

Применение миграции
Теперь нужно применить эту миграцию к базе данных:

```bash
python manage.py migrate
```

Если вы всё сделали правильно, увидите сообщение вроде:

```bash
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, my_app, sessions
Running migrations:
  Applying my_app.0001_initial... OK
```

Готово! Теперь в нашей базе данных появилась таблица `my_app_product`, и в ней три поля: `id (автоинкрементный ключ)`, `name`, `price`.

#### Как проверить, что таблица создана?

Чтобы убедиться, что миграция не применена/применена, используется команда:

```bash
python manage.py showmigrations
```

После выполнения этой команды вы увидите список всех миграций, которые были применены к базе данных:

```bash
$ python manage.py showmigrations
admin
 [X] 0001_initial
 [X] 0002_logentry_remove_auto_add
 [X] 0003_logentry_add_action_flag_choices
auth
 [X] 0001_initial
 [X] 0002_alter_permission_name_max_length
 [X] 0003_alter_user_email_max_length
 [X] 0004_alter_user_username_opts
 [X] 0005_alter_user_last_login_null
 [X] 0006_require_contenttypes_0002
 [X] 0007_alter_validators_add_error_messages
 [X] 0008_alter_user_username_max_length
 [X] 0009_alter_user_last_name_max_length
 [X] 0010_alter_group_name_max_length
 [X] 0011_update_proxy_permissions
 [X] 0012_alter_user_first_name_max_length
contenttypes
 [X] 0001_initial
 [X] 0002_remove_content_type_name
my_app
 [X] 0001_initial # <--- Ваша миграция
sessions
 [X] 0001_initial
```

Если вы видите `[X]` перед вашей миграцией, значит она успешно применена. Если вы видите `[ ]`, значит миграция не применена.

## Админка

`Django Admin` - это специальный веб-интерфейс, который автоматически создаётся вместе с проектом. Через него можно:

- Добавлять, изменять и удалять объекты моделей (например, товары).
- Искать, фильтровать и сортировать данные.
- Управлять пользователями, правами доступа, и многое другое.

### Создаём суперпользователя

Чтобы войти в админку, нужен пользователь с правами администратора. Создаём его с помощью команды:

```bash
python manage.py createsuperuser
```

После ввода этой команды Django поочерёдно попросит ввести:

- Имя пользователя (Username) – обязательно.
- Email address – не обязательно, можно просто нажать Enter.
- Пароль – дважды, для подтверждения.

**Важно! Когда вы вводите пароль — в терминале не отображается ни одна буква или символ. Это нормально и сделано для безопасности.**

![](image/Models_create_admin.png)

#### Что, если пароль слабый?

На скриншоте видно, что Django может не принять введённый пароль и вывести предупреждение:

- `This password is too short.` — пароль слишком короткий.
- `This password is too common.` — слишком простой и легко угадываемый.
- `This password is entirely numeric.` — состоит только из цифр.

Тем не менее, Django спросит:

```pgsql
Bypass password validation and create user anyway? [y/N]:
```

Если вы всё равно хотите создать пользователя с этим паролем (например, для тестов на локальной машине), введите `y` и нажмите `Enter`.

Если все пареметры введены правильно, вы увидите сообщение:

![](image/Models_create_admin_finish.png)

### Проверям URL админки

В файле `urls.py` при создании проекта автоматически добавляется URL для админки, если вы не удаляли его:

```python
urlpatterns = [
    path("admin/", admin.site.urls), # <-- URL админки
    path("", include("my_app.urls"))
]
```
 
### Запуск сервера и вход в админку

Теперь запустите сервер:

```bash
python manage.py runserver
```

После чего откройте браузер и перейдите по адресу в админку:

```plaintext
http://127.0.0.1:8000/admin/
```

![](image/Models_admin_page.png)

Введите имя пользователя и пароль, которые вы создали ранее. Если всё правильно, вы увидите админку:

![](image/Models_admin_page2.png)

Как видно на скриншоте, в админке уже есть модели `User`, `Group`. Это встроенные модели `Django`, которые отвечают за пользователей и группы пользователей. Но нашей модели `Product` там нет. Для этого ее нужно зарегистрировать.

### Добавим модель в админку

Открываем файл `my_app/admin.py` (он уже есть по умолчанию) и добавим:

```python
from django.contrib import admin
from .models import Product  # импортируем нашу модель

admin.site.register(Product)  # регистрируем модель
```

Теперь `Django` "узнает", что модель `Product` должна отображаться в интерфейсе администратора.

Теперь обновим страницу админки и увидим, что модель `Product` появилась в списке:

![](image/Models_admin_page3.png)

Теперь мы можем добавлять, редактировать и удалять товары через админку.

## Кастомная Админка

Когда мы впервые регистрируем модель в админке, Django отображает её "как есть": минимально, без фильтров, без поиска и без колонок, которые могут быть действительно полезны. Но у нас есть мощный инструмент — класс `ModelAdmin`. Сылка на документацию [тут](https://docs.djangoproject.com/en/4.2/ref/contrib/admin/#modeladmin-options).

Давай разберёмся, как сделать админку более информативной и удобной шаг за шагом.

Для начала добавим в нашу модель `Product` меджик-метод `__str__`, который будет возвращать строковое представление объекта. Это нужно, чтобы в админке отображалось название товара, а не его ID:

```python
# models.py
from django.db import models

class Product(models.Model):
    name = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=8, decimal_places=2)

    def __str__(self):
        return self.name
```

Потом в файле `admin.py` добавим класс `ProductAdmin`, который будет наследоваться от `admin.ModelAdmin`. Этот класс позволяет кастомизировать админку для нашей модели:

```python
# admin.py
from django.contrib import admin
from .models import Product

class ProductAdmin(admin.ModelAdmin):
    list_display = ("id", "name", "price")  # колонки, которые будут отображаться
    search_fields = ("name",)               # поле для поиска
    list_filter = ("price",)                # фильтр сбоку

admin.site.register(Product, ProductAdmin)
```

Что мы сделали:

- `list_display` – указали, какие поля должны отображаться в списке объектов. По умолчанию показывается только __str__(), а так — видно и ID, и цену.
- `search_fields` – добавили поле поиска по названию. Теперь можно быстро находить нужный продукт.
- `list_filter` – добавили фильтр по цене. Удобно, если у нас много товаров.

Теперь, создамим несколько товаров через админку и увидим, что интерфейс стал более удобным:

![](image/Models_castom_admin_page.png)

### Изменение формы редактирования

Если мы хотим настроить, какие поля и в каком порядке будут отображаться при создании или редактировании объекта:

```python
class ProductAdmin(admin.ModelAdmin):
    fields = ("name", "price")  # порядок и доступные поля
```

Можно также разбить форму на разделы:

```python
class ProductAdmin(admin.ModelAdmin):
    fieldsets = (
        ("Основная информация", {"fields": ("name",)}),
        ("Финансы", {"fields": ("price",)}),
    )
```

### Дополнительные возможности кастомизации админки

| Возможность           | Описание                                                                 |
|------------------------|--------------------------------------------------------------------------|
| `readonly_fields`      | Делает указанные поля только для чтения в админке.                      |
| `prepopulated_fields`  | Автоматически заполняет поле на основе другого (например, `slug` из `name`).|
| `ordering`             | Задаёт порядок сортировки записей по умолчанию в списке.                |
| `date_hierarchy`       | Добавляет навигацию по датам сверху страницы списка объектов.            |
| `list_per_page`        | Количество объектов на одной странице в списке.                        |

**Пример: более продвинутый ModelAdmin**

```python
from django.contrib import admin
from .models import Product

class ProductAdmin(admin.ModelAdmin):
    list_display = ("id", "name", "price")  # Отображаемые колонки в списке объектов
    list_filter = ("price",)               # Боковой фильтр по полю "price"
    search_fields = ("name",)              # Поиск по полю "name"
    ordering = ("-price",)                 # Сортировка по убыванию цены
    readonly_fields = ("id",)              # Поле "id" нельзя изменить вручную
```

