# Лекция 18. СУБД. DQL. SELECT. Индексы. Group by. Joins.

## DQL (Data query language) (Язык запроса данных)

**DQL (Data Query Language)** – это язык запросов, который используется для получения данных из реляционной базы данных.
Основная команда DQL – это `SELECT`.

**DQL НЕ изменяет данные! В отличие от `INSERT`, `UPDATE` или `DELETE`, он только читает информацию.**


## SELECT

Давайте сделаем простой запрос в БД в табличку `products` которую мы создали на прошлой лекции.

```sql
SELECT * FROM products;
```
Этот запрос вернёт все строки из таблицы `products`. Использовать `SELECT *` можно, но если в таблице много данных, это неэффективно!
Лучше выводить только часть столбцов.

```sql
SELECT name, price FROM products;
```

Теперь мы выведем только столбцы `name` и  `price`

Так же `SQL` не плохо справляется с вычислениями))

```sql
SELECT 13 + 56;
```

Поэтому во время запроса мы можем получать не только значения, но и вычисления.

```sql
SELECT name, price / 2 FROM products;
```

### Фильтрация данных с WHERE

В реальных проектах, доставать все данные из таблицы нужно только в редких случаях.Поэтому чтобы выбрать не все записи, а только нужные, используется `WHERE`.

```sql
SELECT id, name, price FROM products WHERE id = 2;

SELECT id, name, price FROM products WHERE price < 1000;

SELECT id, name, price FROM products WHERE name = 'Телефон';
```

В Первом запросе выведется только один продукт с `id = 2` (так как `id` уникальный для каждого продукта). Во втором запросе выведутся только те продукты у которых цена меньше `1000` (price < 1000). А в третьем получим все продукты с именем `Телефон` (name = 'Телефон')

### Логические операторы AND, OR, NOT

Иногда нужно фильтровать данные по нескольким условиям. Для этого можно использовать, нам уже знакомые логические операторы `AND`, `OR`, `NOT`.

#### Оператор AND (Логическое И)

В запросе оба условия должны быть верны, чтобы вывелся резульятат.

```sql
SELECT id, name, price FROM products WHERE price > 1200 AND name = 'Телефон';
```

Теперь выведутся только те товары, которых цена больше `1200` и у которых название `Телефон`.

#### Оператор OR (Логическое ИЛИ)

Хотя бы одно условие должно быть верным.

```sql
SELECT id, name, price FROM products WHERE price < 1200 OR name = 'Наушники';
```

Выведет все Наушники ИЛИ любые товары дешевле 1200.

#### Оператор NOT (Логическое НЕ) - исключить записи


```sql
SELECT id, name, price FROM products WHERE NOT name = 'Телефон';
```

Выберет все товары, кроме Телефонов.

### Оператор LIKE – Поиск по шаблону

Иногда нужно искать частичное совпадение, например, найти все товары, чьи названия начинаются на `"Н"`.

```sql
SELECT * FROM products WHERE name LIKE 'Н%';
```

**Н% означает: имя начинается с "Н", дальше любые символы.**

Примеры шаблонов `LIKE`

| Шаблон  | Описание                              |
|---------|--------------------------------------|
| 'Н%'    | Наименоование начинается с "Н"               |
| '%Н'    | Наименоование заканчивается на "Н"           |
| '%Н%'   | Наименоование содержит "Н" в любом месте     |
| 'Н_Н'   | Наименоование из трёх букв, вторая "Н"       |


### ORDER BY – Сортировка данных

Чтобы отсортировать результат, используется `ORDER BY`.

####  Сортировка по возрастанию (ASC)

```sql
SELECT * FROM products ORDER BY price ASC;
```

После данного наши товары отсортируются от самого дешевого до самого дорогого.


### Сортировка по нескольким колонкам

```sql
SELECT * FROM products ORDER BY name DESC, price ASC;
```

Тут будет отсортировано сначала по Названию ,потом по цене (от самого дешевого до дорогого)

###  LIMIT – Ограничение количества строк

Если нужно вывести только первые `N` записей, используется `LIMIT`.

```sql
SELECT * FROM products LIMIT 5;
```

Вывод 5 первых товаров.

Если нужно вернуть какойто промежуток данных, то можно использовать `OFFSET`.

```sql
SELECT * FROM products LIMIT 5 OFFSET 5;
```
Вернет значения с 5-ого по 10-е. `OFFSET` - сдвиг по данным.

**Все также можно комбинировать запрос**

```sql
SELECT * FROM products ORDER BY price ASC LIMIT 3;
```

Теперь мы выведем 3 самых дешевых товара))

### DISTINCT – Удаление дубликатов

Если нужно вывести только уникальные значения, используется `DISTINCT`.

```sql
SELECT DISTINCT name FROM products;
```

Этот запрос уберёт дубликаты и вернёт только уникальные названия товаров.


## Индексация в Базах Данных (Indexes)

**Индексы в базе данных** – это специальные структуры, которые ускоряют поиск данных в таблицах. Они работают похожим образом на содержание книги: вместо того, чтобы перебирать всю таблицу, база использует индекс, чтобы быстро найти нужные строки.

### Зачем нужны индексы?

- Когда таблица маленькая (до 1000 строк) – поиск работает быстро.
- Когда таблица большая (миллионы строк) – обычный поиск становится медленным.
- Индексы помогают быстро находить данные, уменьшая количество сканируемых строк.

### Типы индексов

В `PostgreSQL` есть разные виды индексов. Самые важные:

| Тип индекса                  | Описание                                                   |
|------------------------------|-----------------------------------------------------------|
| **B-Tree (по умолчанию)**    | Самый распространённый индекс для поиска, сравнения и сортировки. |
| **Hash**                     | Оптимален для поиска по `=` (равно).                      |
| **GIN (Generalized Inverted Index)** | Используется для поиска по массивам, JSON и полнотекстовому поиску. |
| **GiST (Generalized Search Tree)**  | Подходит для географических данных и поиска по диапазонам. |
| **BRIN (Block Range Index)** | Хорош для больших таблиц, в которых данные отсортированы. |

### Создание индексов

**Пример без индекса**

```sql
SELECT * FROM products WHERE name = 'Телефон';
```

Если в таблице миллион строк, поиск будет медленным, так как база данных будет проверять каждую строку.

**Пример с индексом**

```sql
CREATE INDEX idx_product_name ON products(name);
```

Теперь поиск будет намного быстрее, так как `PostgreSQL` будет использовать индекс вместо полного перебора строк.


#### Создание индекса для нескольких колонок

```sql
CREATE INDEX idx_product_name_price ON products(name, price);
```

Этот индекс будет ускорять запросы, которые используют сразу `name` и `price`.

#### Создание уникального индекса

```sql
CREATE UNIQUE INDEX idx_unique_product_name ON products(name);
```

 Этот индекс гарантирует, что в таблице `products` не будет товаров с одинаковыми названиями.

Эквивалентно `UNIQUE` при создании таблицы

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT UNIQUE,
    price NUMERIC,
    description TEXT
);
```

 В этом случае `PostgreSQL` автоматически создаст уникальный индекс на `name`.

**Проверка работы индекса**

Попробуем добавить дубликаты

```sql
INSERT INTO products (name, price, description) 
VALUES ('Телефон', 1400, 'Айфон');
```

Запрос выполнится успешно.

```sql
INSERT INTO products (name, price, description) 
VALUES ('Телефон', 1200, 'Самсунг');
```

Ошибка! Нарушено уникальное ограничение: `name` уже есть в базе.


**Индексы и сортировка**

```sql
SELECT *
FROM products
ORDER BY name;
```

Индекс на `name` также ускорит выполнение этого запроса.

### Управление индексами

Просмотр существующих индексовЧтобы увидеть все индексы в таблице, можно использовать следующую команду:

```sql
\d table_name
```

**Удаление индекса**

Если индекс больше не нужен, его можно удалить:

```sql
DROP INDEX idx_unique_product_name;
```

### Проблемы связанные с индексами

А если все так хорошо и быстро, почему бы нам не создать индексы вообще на все поля и все будет работать быстрее?

И да и нет.

Если бы у нас были только операции чтения, то это было бы идеальное решение. Но у нас есть и другие операции.

Представте книгу у которой есть оглавление (по сути та же индексация). Пока мы можем только читать книгу, проблем нет,
добавили несколько страниц в начале, чем упростили жизнь.

Но теперь представте, что вы в эту книгу начинаете дописывать/удалять/изменять страницы или целые главы.

Для каждой такой операции, оглавление придется переписывать заново.

> Если в таблицу часто производится запись/изменение/удаление, то индекс только замедлил работу базы! А он еще и место
> занимает! Поэтому всегда нужно очень аккуратно относиться к индексам, это очень хороший инструмент, который легко
> может
> все сломать

## Встроенные функции в PostgreSQL

**Встроенные функции** – это готовые функции в `PostgreSQL`, которые позволяют изменять, анализировать и агрегировать данные прямо в SQL-запросах. С их помощью можно работать со строками, числами, датами, массивами, JSON и многим другим.

### Логические операторы и операторы сравнения

Таблица истинности для SQL, учитывающая `NULL`, отличается от обычной таблицы истинности, так как `NULL` в SQL
представляет неопределенное значение. В операциях сравнения и логических операциях `NULL` ведет себя особым образом.

Вот таблица истинности для SQL с учетом `NULL`:

### Логические операторы (AND, OR, NOT)

| A     | B     | A AND B | A OR B | NOT A |
|-------|-------|---------|--------|-------|
| TRUE  | TRUE  | TRUE    | TRUE   | FALSE |
| TRUE  | FALSE | FALSE   | TRUE   | FALSE |
| TRUE  | NULL  | NULL    | TRUE   | FALSE |
| FALSE | TRUE  | FALSE   | TRUE   | TRUE  |
| FALSE | FALSE | FALSE   | FALSE  | TRUE  |
| FALSE | NULL  | FALSE   | NULL   | TRUE  |
| NULL  | TRUE  | NULL    | TRUE   | NULL  |
| NULL  | FALSE | FALSE   | NULL   | NULL  |
| NULL  | NULL  | NULL    | NULL   | NULL  |

### Операторы сравнения (=, <>, <, >, <=, >=)

| A     | B     | A = B | A <> B | A < B | A > B | A <= B | A >= B |
|-------|-------|-------|--------|-------|-------|--------|--------|
| TRUE  | TRUE  | TRUE  | FALSE  | FALSE | FALSE | TRUE   | TRUE   |
| TRUE  | FALSE | FALSE | TRUE   | FALSE | TRUE  | FALSE  | TRUE   |
| TRUE  | NULL  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| FALSE | TRUE  | FALSE | TRUE   | TRUE  | FALSE | TRUE   | FALSE  |
| FALSE | FALSE | TRUE  | FALSE  | FALSE | FALSE | TRUE   | TRUE   |
| FALSE | NULL  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| NULL  | TRUE  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| NULL  | FALSE | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| NULL  | NULL  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |

### Примечания:

1. **Логические операторы:**
    - `A AND B` вернет `TRUE`, только если оба значения `TRUE`.
    - `A OR B` вернет `TRUE`, если хотя бы одно значение `TRUE`.
    - `NOT A` вернет противоположное значение, если `A` не `NULL`.

2. **Операторы сравнения:**
    - Любое сравнение с `NULL` всегда возвращает `NULL` (неопределенное).

Эти правила делают работу с `NULL` в SQL специфической, и при работе с данными нужно учитывать, что `NULL` не
эквивалентен ни `TRUE`, ни `FALSE`, а представляет собой третье состояние, которое требует особого внимания при
логических и сравнительных операциях.

### Виды встроенных функций

| Категория функций          | Описание |
|----------------------------|-------------------------------------------------------------|
| **Агрегатные функции**     | Выполняют расчёты по группе строк (`SUM`, `AVG`, `COUNT`, `MAX`, `MIN`). |
| **Функции работы со строками** | Обрабатывают текст (`UPPER`, `LOWER`, `LENGTH`, `SUBSTRING`). |
| **Функции работы с числами**   | Математические вычисления (`ROUND`, `ABS`, `CEIL`, `FLOOR`). |
| **Функции работы с датами**    | Работа с датами и временем (`NOW`, `CURRENT_DATE`, `AGE`, `EXTRACT`). |
| **Функции для массивов**       | Операции с массивами (`ARRAY_LENGTH`, `ARRAY_APPEND`). |
| **Функции для JSON**           | Обработка JSON-данных (`JSONB_EXTRACT_PATH_TEXT`). |

#### Агрегатные функции

Агрегатные функции используются с `GROUP BY`, чтобы делать расчёты по нескольким строкам.

| Функция  | Описание |
|----------|--------------------------------|
| **SUM()**  | Считает сумму значений. |
| **AVG()**  | Вычисляет среднее значение. |
| **COUNT()** | Подсчитывает количество строк. |
| **MAX()**  | Находит максимальное значение. |
| **MIN()**  | Находит минимальное значение. |

**Общая сумма всех товаров**

```sql
SELECT SUM(price) FROM products;
```

**Средняя цена товаров**

```sql
SELECT AVG(price) FROM products;
```

**Сколько товаров в таблице**

```sql
SELECT COUNT(*) FROM products;
```

**Самый дорогой товар**

```sql
SELECT MAX(price) FROM products;
```

**Самый дешёвый товар**

```sql
SELECT MIN(price) FROM products;
```

### Функции работы со строками (TEXT)

| Функция                          | Описание |
|----------------------------------|---------------------------------------------|
| **UPPER(text)**                  | Преобразует строку в **верхний регистр**.  |
| **LOWER(text)**                  | Преобразует строку в **нижний регистр**.   |
| **LENGTH(text)**                 | Возвращает **количество символов** в строке. |
| **SUBSTRING(text, start, length)** | Извлекает **часть строки**.                |
| **CONCAT(str1, str2, ...)**      | Объединяет строки.                         |


**Преобразуем названия товаров в верхний регистр**

```sql
SELECT UPPER(name) FROM products;
```

**Считаем длину названия каждого товара**

```sql
SELECT name, LENGTH(name) FROM products;
```

**Берём первые 5 символов из названия**

```sql
SELECT name, SUBSTRING(name FROM 1 FOR 5) FROM products;
```

**Объединяем название и описание товара**

```sql
SELECT CONCAT(name, ' - ', description) FROM products;
```

### Функции работы с числами

| Функция              | Описание |
|----------------------|--------------------------------------------------|
| **ROUND(number, n)** | Округляет число до `n` знаков после запятой.   |
| **CEIL(number)**     | Округляет **вверх** (до ближайшего целого).    |
| **FLOOR(number)**    | Округляет **вниз** (до ближайшего целого).     |
| **ABS(number)**      | Возвращает **модуль числа**.                   |
| **RANDOM()**        | Генерирует случайное число от `0` до `1`.      |


**Округляем цену до 2 знаков после запятой**

```sql
SELECT name, ROUND(price, 2) FROM products;
```

**Округляем цену в большую сторону**

```sql
SELECT name, CEIL(price) FROM products;
```

**Округляем цену в меньшую сторону**

```sql
SELECT name, FLOOR(price) FROM products;
```

**Генерируем случайное число от 0 до 1**

```sql
SELECT RANDOM();
```

### Функции работы с датами и временем

| Функция                      | Описание |
|------------------------------|--------------------------------------|
| **NOW()**                    | Текущая дата и время.               |
| **CURRENT_DATE**             | Текущая дата (без времени).         |
| **AGE(date1, date2)**        | Разница между датами.               |
| **EXTRACT(field FROM date)** | Извлекает год, месяц, день, час и т. д. |

**Получить текущую дату и время**

```sql
SELECT NOW();
```

**Получить только текущую дату**


```sql
SELECT CURRENT_DATE;
```

**Узнать возраст товара, если есть дата его добавления**

```sql
SELECT name, AGE(NOW(), created_at) FROM products;
```

**Извлекаем год из даты создания**

```sql
SELECT name, EXTRACT(YEAR FROM created_at) FROM products;
```

### Функции для работы с массивами

| Функция                          | Описание |
|----------------------------------|---------------------------------------------|
| **ARRAY_LENGTH(array, dim)**     | Длина массива.                              |
| **ARRAY_APPEND(array, element)** | Добавляет элемент в массив.                 |
| **ARRAY_REMOVE(array, element)** | Удаляет элемент из массива.                 |
| **UNNEST(array)**                | Разворачивает массив в строки.              |


**Создаём массив и узнаём его длину**

```sql
SELECT ARRAY_LENGTH(ARRAY['Apple', 'Samsung', 'Xiaomi'], 1);
```

**Добавляем элемент в массив**

```sql
SELECT ARRAY_APPEND(ARRAY['Apple', 'Samsung'], 'Huawei');
```

### Функции работы с JSON (JSONB)

| Функция                               | Описание |
|---------------------------------------|----------------------------------------------|
| **JSONB_EXTRACT_PATH_TEXT(json, 'key')** | Извлекает значение по ключу.                |
| **JSONB_OBJECT_KEYS(json)**           | Показывает все ключи JSON-объекта.          |

**Допустим, у нас есть колонка data с JSON**

```sql
SELECT JSONB_EXTRACT_PATH_TEXT('{"name": "iPhone", "price": 1000}', 'price');
```

**Получить список ключей JSON-объекта**

```sql
SELECT JSONB_OBJECT_KEYS('{"name": "iPhone", "price": 1000}');
```
