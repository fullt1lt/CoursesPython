# Лекция 18. СУБД. DQL. SELECT. Индексы. Group by. Joins.

## DQL (Data query language) (Язык запроса данных)

**DQL (Data Query Language)** – это язык запросов, который используется для получения данных из реляционной базы данных.
Основная команда DQL – это `SELECT`.

**DQL НЕ изменяет данные! В отличие от `INSERT`, `UPDATE` или `DELETE`, он только читает информацию.**


## SELECT

Давайте сделаем простой запрос в БД в табличку `products` которую мы создали на прошлой лекции.

```sql
SELECT * FROM products;
```
Этот запрос вернёт все строки из таблицы `products`. Использовать `SELECT *` можно, но если в таблице много данных, это неэффективно!
Лучше выводить только часть столбцов.

```sql
SELECT name, price FROM products;
```

Теперь мы выведем только столбцы `name` и  `price`

Так же `SQL` не плохо справляется с вычислениями))

```sql
SELECT 13 + 56;
```

Поэтому во время запроса мы можем получать не только значения, но и вычисления.

```sql
SELECT name, price / 2 FROM products;
```

### Фильтрация данных с WHERE

В реальных проектах, доставать все данные из таблицы нужно только в редких случаях.Поэтому чтобы выбрать не все записи, а только нужные, используется `WHERE`.

```sql
SELECT id, name, price FROM products WHERE id = 2;

SELECT id, name, price FROM products WHERE price < 1000;

SELECT id, name, price FROM products WHERE name = 'Телефон';
```

В Первом запросе выведется только один продукт с `id = 2` (так как `id` уникальный для каждого продукта). Во втором запросе выведутся только те продукты у которых цена меньше `1000` (price < 1000). А в третьем получим все продукты с именем `Телефон` (name = 'Телефон')

### Логические операторы AND, OR, NOT

Иногда нужно фильтровать данные по нескольким условиям. Для этого можно использовать, нам уже знакомые логические операторы `AND`, `OR`, `NOT`.

#### Оператор AND (Логическое И)

В запросе оба условия должны быть верны, чтобы вывелся резульятат.

```sql
SELECT id, name, price FROM products WHERE price > 1200 AND name = 'Телефон';
```

Теперь выведутся только те товары, которых цена больше `1200` и у которых название `Телефон`.

#### Оператор OR (Логическое ИЛИ)

Хотя бы одно условие должно быть верным.

```sql
SELECT id, name, price FROM products WHERE price < 1200 OR name = 'Наушники';
```

Выведет все Наушники ИЛИ любые товары дешевле 1200.

#### Оператор NOT (Логическое НЕ) - исключить записи


```sql
SELECT id, name, price FROM products WHERE NOT name = 'Телефон';
```

Выберет все товары, кроме Телефонов.

### Оператор LIKE – Поиск по шаблону

Иногда нужно искать частичное совпадение, например, найти все товары, чьи названия начинаются на `"Н"`.

```sql
SELECT * FROM products WHERE name LIKE 'Н%';
```

**Н% означает: имя начинается с "Н", дальше любые символы.**

Примеры шаблонов `LIKE`

| Шаблон  | Описание                              |
|---------|--------------------------------------|
| 'Н%'    | Наименоование начинается с "Н"               |
| '%Н'    | Наименоование заканчивается на "Н"           |
| '%Н%'   | Наименоование содержит "Н" в любом месте     |
| 'Н_Н'   | Наименоование из трёх букв, вторая "Н"       |


### ORDER BY – Сортировка данных

Чтобы отсортировать результат, используется `ORDER BY`.

####  Сортировка по возрастанию (ASC)

```sql
SELECT * FROM products ORDER BY price ASC;
```

После данного наши товары отсортируются от самого дешевого до самого дорогого.

#### Сортировка по убыванию (DESC)

```sql
SELECT * FROM products ORDER BY price DESC;
```
Товары отсортируются от самого дорого к дешевому.

### Сортировка по нескольким колонкам

```sql
SELECT * FROM products ORDER BY name DESC, price ASC;
```

Тут будет отсортировано сначала по Названию ,потом по цене (от самого дешевого до дорогого)

###  LIMIT – Ограничение количества строк

Если нужно вывести только первые `N` записей, используется `LIMIT`.

```sql
SELECT * FROM products LIMIT 5;
```

Вывод 5 первых товаров.

Если нужно вернуть какойто промежуток данных, то можно использовать `OFFSET`.

```sql
SELECT * FROM products LIMIT 5 OFFSET 5;
```
Вернет значения с 5-ого по 10-е. `OFFSET` - сдвиг по данным.

**Все также можно комбинировать запрос**

```sql
SELECT * FROM products ORDER BY price ASC LIMIT 3;
```

Теперь мы выведем 3 самых дешевых товара))

### DISTINCT – Удаление дубликатов

Если нужно вывести только уникальные значения, используется `DISTINCT`.

```sql
SELECT DISTINCT name FROM products;
```

Этот запрос уберёт дубликаты и вернёт только уникальные названия товаров.


## Индексация в Базах Данных (Indexes)

**Индексы в базе данных** – это специальные структуры, которые ускоряют поиск данных в таблицах. Они работают похожим образом на содержание книги: вместо того, чтобы перебирать всю таблицу, база использует индекс, чтобы быстро найти нужные строки.

### Зачем нужны индексы?

- Когда таблица маленькая (до 1000 строк) – поиск работает быстро.
- Когда таблица большая (миллионы строк) – обычный поиск становится медленным.
- Индексы помогают быстро находить данные, уменьшая количество сканируемых строк.

### Типы индексов

В `PostgreSQL` есть разные виды индексов. Самые важные:

| Тип индекса                  | Описание                                                   |
|------------------------------|-----------------------------------------------------------|
| **B-Tree (по умолчанию)**    | Самый распространённый индекс для поиска, сравнения и сортировки. |
| **Hash**                     | Оптимален для поиска по `=` (равно).                      |
| **GIN (Generalized Inverted Index)** | Используется для поиска по массивам, JSON и полнотекстовому поиску. |
| **GiST (Generalized Search Tree)**  | Подходит для географических данных и поиска по диапазонам. |
| **BRIN (Block Range Index)** | Хорош для больших таблиц, в которых данные отсортированы. |

### Создание индексов

**Пример без индекса**

```sql
SELECT * FROM products WHERE name = 'Телефон';
```

Если в таблице миллион строк, поиск будет медленным, так как база данных будет проверять каждую строку.

**Пример с индексом**

```sql
CREATE INDEX idx_product_name ON products(name);
```

Теперь поиск будет намного быстрее, так как `PostgreSQL` будет использовать индекс вместо полного перебора строк.


#### Создание индекса для нескольких колонок

```sql
CREATE INDEX idx_product_name_price ON products(name, price);
```

Этот индекс будет ускорять запросы, которые используют сразу `name` и `price`.

#### Создание уникального индекса

```sql
CREATE UNIQUE INDEX idx_unique_product_name ON products(name);
```

 Этот индекс гарантирует, что в таблице `products` не будет товаров с одинаковыми названиями.

Эквивалентно `UNIQUE` при создании таблицы

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT UNIQUE,
    price NUMERIC,
    description TEXT
);
```

 В этом случае `PostgreSQL` автоматически создаст уникальный индекс на `name`.

**Проверка работы индекса**

Попробуем добавить дубликаты

```sql
INSERT INTO products (name, price, description) 
VALUES ('Телефон', 1400, 'Айфон');
```

Запрос выполнится успешно.

```sql
INSERT INTO products (name, price, description) 
VALUES ('Телефон', 1200, 'Самсунг');
```

Ошибка! Нарушено уникальное ограничение: `name` уже есть в базе.


**Индексы и сортировка**

```sql
SELECT *
FROM products
ORDER BY name;
```

Индекс на `name` также ускорит выполнение этого запроса.

### Управление индексами

Просмотр существующих индексовЧтобы увидеть все индексы в таблице, можно использовать следующую команду:

```sql
\d table_name
```

**Удаление индекса**

Если индекс больше не нужен, его можно удалить:

```sql
DROP INDEX idx_unique_product_name;
```

### Проблемы связанные с индексами

А если все так хорошо и быстро, почему бы нам не создать индексы вообще на все поля и все будет работать быстрее?

И да и нет.

Если бы у нас были только операции чтения, то это было бы идеальное решение. Но у нас есть и другие операции.

Представте книгу у которой есть оглавление (по сути та же индексация). Пока мы можем только читать книгу, проблем нет,
добавили несколько страниц в начале, чем упростили жизнь.

Но теперь представте, что вы в эту книгу начинаете дописывать/удалять/изменять страницы или целые главы.

Для каждой такой операции, оглавление придется переписывать заново.

> Если в таблицу часто производится запись/изменение/удаление, то индекс только замедлил работу базы! А он еще и место
> занимает! Поэтому всегда нужно очень аккуратно относиться к индексам, это очень хороший инструмент, который легко
> может
> все сломать

## Встроенные функции в PostgreSQL

**Встроенные функции** – это готовые функции в `PostgreSQL`, которые позволяют изменять, анализировать и агрегировать данные прямо в SQL-запросах. С их помощью можно работать со строками, числами, датами, массивами, JSON и многим другим.

### Логические операторы и операторы сравнения

Таблица истинности для SQL, учитывающая `NULL`, отличается от обычной таблицы истинности, так как `NULL` в SQL
представляет неопределенное значение. В операциях сравнения и логических операциях `NULL` ведет себя особым образом.

Вот таблица истинности для SQL с учетом `NULL`:

### Логические операторы (AND, OR, NOT)

| A     | B     | A AND B | A OR B | NOT A |
|-------|-------|---------|--------|-------|
| TRUE  | TRUE  | TRUE    | TRUE   | FALSE |
| TRUE  | FALSE | FALSE   | TRUE   | FALSE |
| TRUE  | NULL  | NULL    | TRUE   | FALSE |
| FALSE | TRUE  | FALSE   | TRUE   | TRUE  |
| FALSE | FALSE | FALSE   | FALSE  | TRUE  |
| FALSE | NULL  | FALSE   | NULL   | TRUE  |
| NULL  | TRUE  | NULL    | TRUE   | NULL  |
| NULL  | FALSE | FALSE   | NULL   | NULL  |
| NULL  | NULL  | NULL    | NULL   | NULL  |

### Операторы сравнения (=, <>, <, >, <=, >=)

| A     | B     | A = B | A <> B | A < B | A > B | A <= B | A >= B |
|-------|-------|-------|--------|-------|-------|--------|--------|
| TRUE  | TRUE  | TRUE  | FALSE  | FALSE | FALSE | TRUE   | TRUE   |
| TRUE  | FALSE | FALSE | TRUE   | FALSE | TRUE  | FALSE  | TRUE   |
| TRUE  | NULL  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| FALSE | TRUE  | FALSE | TRUE   | TRUE  | FALSE | TRUE   | FALSE  |
| FALSE | FALSE | TRUE  | FALSE  | FALSE | FALSE | TRUE   | TRUE   |
| FALSE | NULL  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| NULL  | TRUE  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| NULL  | FALSE | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |
| NULL  | NULL  | NULL  | NULL   | NULL  | NULL  | NULL   | NULL   |

### Примечания:

1. **Логические операторы:**
    - `A AND B` вернет `TRUE`, только если оба значения `TRUE`.
    - `A OR B` вернет `TRUE`, если хотя бы одно значение `TRUE`.
    - `NOT A` вернет противоположное значение, если `A` не `NULL`.

2. **Операторы сравнения:**
    - Любое сравнение с `NULL` всегда возвращает `NULL` (неопределенное).

Эти правила делают работу с `NULL` в SQL специфической, и при работе с данными нужно учитывать, что `NULL` не
эквивалентен ни `TRUE`, ни `FALSE`, а представляет собой третье состояние, которое требует особого внимания при
логических и сравнительных операциях.

### Виды встроенных функций

| Категория функций          | Описание |
|----------------------------|-------------------------------------------------------------|
| **Агрегатные функции**     | Выполняют расчёты по группе строк (`SUM`, `AVG`, `COUNT`, `MAX`, `MIN`). |
| **Функции работы со строками** | Обрабатывают текст (`UPPER`, `LOWER`, `LENGTH`, `SUBSTRING`). |
| **Функции работы с числами**   | Математические вычисления (`ROUND`, `ABS`, `CEIL`, `FLOOR`). |
| **Функции работы с датами**    | Работа с датами и временем (`NOW`, `CURRENT_DATE`, `AGE`, `EXTRACT`). |
| **Функции для массивов**       | Операции с массивами (`ARRAY_LENGTH`, `ARRAY_APPEND`). |
| **Функции для JSON**           | Обработка JSON-данных (`JSONB_EXTRACT_PATH_TEXT`). |

#### Агрегатные функции

Агрегатные функции используются с `GROUP BY`, чтобы делать расчёты по нескольким строкам.

| Функция  | Описание |
|----------|--------------------------------|
| **SUM()**  | Считает сумму значений. |
| **AVG()**  | Вычисляет среднее значение. |
| **COUNT()** | Подсчитывает количество строк. |
| **MAX()**  | Находит максимальное значение. |
| **MIN()**  | Находит минимальное значение. |

**Общая сумма всех товаров**

```sql
SELECT SUM(price) FROM products;
```

**Средняя цена товаров**

```sql
SELECT AVG(price) FROM products;
```

**Сколько товаров в таблице**

```sql
SELECT COUNT(*) FROM products;
```

**Самый дорогой товар**

```sql
SELECT MAX(price) FROM products;
```

**Самый дешёвый товар**

```sql
SELECT MIN(price) FROM products;
```

### Функции работы со строками (TEXT)

| Функция                          | Описание |
|----------------------------------|---------------------------------------------|
| **UPPER(text)**                  | Преобразует строку в **верхний регистр**.  |
| **LOWER(text)**                  | Преобразует строку в **нижний регистр**.   |
| **LENGTH(text)**                 | Возвращает **количество символов** в строке. |
| **SUBSTRING(text, start, length)** | Извлекает **часть строки**.                |
| **CONCAT(str1, str2, ...)**      | Объединяет строки.                         |


**Преобразуем названия товаров в верхний регистр**

```sql
SELECT UPPER(name) FROM products;
```

**Считаем длину названия каждого товара**

```sql
SELECT name, LENGTH(name) FROM products;
```

**Берём первые 5 символов из названия**

```sql
SELECT name, SUBSTRING(name FROM 1 FOR 5) FROM products;
```

**Объединяем название и описание товара**

```sql
SELECT CONCAT(name, ' - ', description) FROM products;
```

### Функции работы с числами

| Функция              | Описание |
|----------------------|--------------------------------------------------|
| **ROUND(number, n)** | Округляет число до `n` знаков после запятой.   |
| **CEIL(number)**     | Округляет **вверх** (до ближайшего целого).    |
| **FLOOR(number)**    | Округляет **вниз** (до ближайшего целого).     |
| **ABS(number)**      | Возвращает **модуль числа**.                   |
| **RANDOM()**        | Генерирует случайное число от `0` до `1`.      |


**Округляем цену до 2 знаков после запятой**

```sql
SELECT name, ROUND(price, 2) FROM products;
```

**Округляем цену в большую сторону**

```sql
SELECT name, CEIL(price) FROM products;
```

**Округляем цену в меньшую сторону**

```sql
SELECT name, FLOOR(price) FROM products;
```

**Генерируем случайное число от 0 до 1**

```sql
SELECT RANDOM();
```

### Функции работы с датами и временем

| Функция                      | Описание |
|------------------------------|--------------------------------------|
| **NOW()**                    | Текущая дата и время.               |
| **CURRENT_DATE**             | Текущая дата (без времени).         |
| **AGE(date1, date2)**        | Разница между датами.               |
| **EXTRACT(field FROM date)** | Извлекает год, месяц, день, час и т. д. |

**Получить текущую дату и время**

```sql
SELECT NOW();
```

**Получить только текущую дату**


```sql
SELECT CURRENT_DATE;
```

**Узнать возраст товара, если есть дата его добавления**

```sql
SELECT name, AGE(NOW(), created_at) FROM products;
```

**Извлекаем год из даты создания**

```sql
SELECT name, EXTRACT(YEAR FROM created_at) FROM products;
```

### Функции для работы с массивами

| Функция                          | Описание |
|----------------------------------|---------------------------------------------|
| **ARRAY_LENGTH(array, dim)**     | Длина массива.                              |
| **ARRAY_APPEND(array, element)** | Добавляет элемент в массив.                 |
| **ARRAY_REMOVE(array, element)** | Удаляет элемент из массива.                 |
| **UNNEST(array)**                | Разворачивает массив в строки.              |


**Создаём массив и узнаём его длину**

```sql
SELECT ARRAY_LENGTH(ARRAY['Apple', 'Samsung', 'Xiaomi'], 1);
```

**Добавляем элемент в массив**

```sql
SELECT ARRAY_APPEND(ARRAY['Apple', 'Samsung'], 'Huawei');
```

### Функции работы с JSON (JSONB)

| Функция                               | Описание |
|---------------------------------------|----------------------------------------------|
| **JSONB_EXTRACT_PATH_TEXT(json, 'key')** | Извлекает значение по ключу.                |
| **JSONB_OBJECT_KEYS(json)**           | Показывает все ключи JSON-объекта.          |

**Допустим, у нас есть колонка data с JSON**

```sql
SELECT JSONB_EXTRACT_PATH_TEXT('{"name": "iPhone", "price": 1000}', 'price');
```

**Получить список ключей JSON-объекта**

```sql
SELECT JSONB_OBJECT_KEYS('{"name": "iPhone", "price": 1000}');
```

## GROUP BY и HAVING в SQL

**GROUP BY** — это мощная команда `SQL`, которая позволяет группировать строки в таблице по одному или нескольким столбцам. Это особенно полезно, когда нужно агрегировать данные, например, суммировать, подсчитывать или находить средние значения. `GROUP BY` часто используется вместе с агрегатными функциями, такими как `COUNT`, `SUM`, `AVG`, `MAX` и `MIN`. Группировка данных позволяет более эффективно анализировать большие объемы информации, выявлять тенденции и аномалии, а также создавать сводные отчеты.

**Синтаксис GROUP BY**

```sql
SELECT column_name, AGGREGATE_FUNCTION(column_name)
FROM table_name
GROUP BY column_name;
```

### Агрегатные функции в SQL

**Агрегатные функции** – это специальные SQL-функции, которые позволяют выполнять расчёты над группами строк.

| Функция  | Описание |
|----------|--------------------------------------------|
| **COUNT()**  | Подсчитывает количество строк в группе. |
| **SUM()**    | Считает сумму значений в группе. |
| **AVG()**    | Вычисляет среднее значение. |
| **MAX()**    | Находит максимальное значение. |
| **MIN()**    | Находит минимальное значение. |

Давайте разберем примеры использования агрегатных функций на таблице `products`.

| id | name       | price  | description | rating |
|----|-----------|--------|------------|--------|
| 1  | Телефон   | 1200.00 | Самсунг    | 2      |
| 2  | Телефон   | 1400.00 | Айфон      | 5      |
| 3  | Наушники  | 200.00  | Ксяоми     | 5      |
| 4  | Ноутбук   | 1000.00 | Леново     | 4      |
| 5  | Наушники  | 150.00  | JBL        | 4      |

#### COUNT() – Подсчёт количества товаров каждого типа

```sql
SELECT name, COUNT(*) AS count_products 
FROM products 
GROUP BY name;
```

Группирует товары по `name` и считает количество строк в каждой группе.

| name       | count_products |
|------------|---------------|
| Телефон    | 2             |
| Наушники   | 2             |
| Ноутбук    | 1             |


#### SUM() – Общая стоимость товаров каждого типа

```sql
SELECT name, SUM(price) AS total_price
FROM products
GROUP BY name;
```
Группирует товары по `name` и суммирует `price`.

| name       | total_price |
|------------|------------|
| Телефон    | 2600.00    |
| Наушники   | 350.00     |
| Ноутбук    | 1000.00    |


#### AVG() – Средняя цена каждого типа товаров

```sql
SELECT name, AVG(price) AS avg_price
FROM products
GROUP BY name;
```

Группирует товары по name и считает `AVG(price)`.

| name       | avg_price |
|------------|-----------|
| Телефон    | 1300.00   |
| Наушники   | 175.00    |
| Ноутбук    | 1000.00   |

#### MAX() – Самый дорогой товар каждого типа

```sql
SELECT name, MAX(price) AS max_price
FROM products
GROUP BY name;
```

 Находит максимальную цену `(MAX(price))` для каждого типа товара.

 | name       | max_price |
|------------|-----------|
| Телефон    | 1400.00   |
| Наушники   | 200.00    |
| Ноутбук    | 1000.00   |

#### MIN() – Самый дешёвый товар каждого типа

```sql
SELECT name, MIN(price) AS min_price
FROM products
GROUP BY name;
```

Находит минимальную цену `(MIN(price))` для каждого типа товара.

| name       | min_price |
|------------|-----------|
| Телефон    | 1200.00   |
| Наушники   | 150.00    |
| Ноутбук    | 1000.00   |

### HAVING – Фильтрация после GROUP BY

HAVING используется для фильтрации групп после применения агрегатных функций. Например, если мы хотим отобрать только те категории, в которых больше 10 товаров.

#### Чем отличается HAVING от WHERE?

| 🔹 `WHERE` | 🔹 `HAVING` |
|---------------|------------------------------------|
| Фильтрует строки **до** `GROUP BY`. | Фильтрует группы **после** `GROUP BY`. |
| Нельзя использовать агрегатные функции. | Можно использовать агрегатные функции. |


**Оставить только группы, где больше 1 товара**

```sql
SELECT name, COUNT(*) AS count_products
FROM products
GROUP BY name
HAVING COUNT(*) > 1;
```

Оставляет только группы, в которых товаров больше 1.

**Оставить товары, у которых средняя цена выше 500**

```sql
SELECT name, AVG(price) AS avg_price
FROM products
GROUP BY name
HAVING AVG(price) > 500;
```

Оставляет только товары, у которых `AVG(price) > 500.`

## Вложенные запросы (Subqueries)

**Вложенный запрос (или Subquery)** – это SQL-запрос, который выполняется внутри другого запроса. Вложенные запросы используются, когда нам нужно сначала получить одни данные, а затем использовать их в другом запросе.

### Вложенные запросы в WHERE

Допустим, нам нужно выбрать все товары, у которых цена выше средней.

```sql
SELECT * 
FROM products 
WHERE price > (SELECT AVG(price) FROM products);
```

**Как это работает?**

Вложенный запрос `SELECT AVG(price) FROM products` считает среднюю цену. Основной запрос выбирает только те товары, у которых price > средняя цена.

### Вложенные запросы в SELECT

Допустим, мы хотим вывести название товара и его место в рейтинге по цене.

```sql
SELECT name, price, 
       (SELECT COUNT(*) FROM products p2 WHERE p2.price > p1.price) + 1 AS rank
FROM products p1
ORDER BY rank;
```

**Как это работает?**

Вложенный запрос считает, сколько товаров дороже текущего **(p1.price).** К этому числу добавляется 1, чтобы получить ранг товара по цене.

| name       | price  | rank |
|------------|--------|------|
| Наушники  | 150.00  | 5    |
| Наушники  | 200.00  | 4    |
| Ноутбук   | 1000.00 | 3    |
| Телефон   | 1200.00 | 2    |
| Телефон   | 1400.00 | 1    |

Теперь у нас товары сортированы по цене.

### Вложенные запросы в FROM (Derived Tables)

Если мы хотим использовать результат одного запроса как временную таблицу, мы можем использовать вложенный запрос в `FROM`. Допустим, мы хотим выбрать все товары, чья цена выше средней, но сразу добавить среднюю цену в вывод.

```sql
SELECT p.*, avg_price 
FROM products p, 
     (SELECT AVG(price) AS avg_price FROM products) AS subquery
WHERE p.price > subquery.avg_price;
```

**Как это работает?**

Вложенный запрос (`subquery`) считает `AVG(price)` и создаёт временную таблицу `subquery`. Основной запрос обращается к этой таблице и фильтрует товары, где `p.price` > `avg_price`.

| id  | name     | price  | description | rating | avg_price |
|---- |---------|--------|-------------|--------|-----------|
| 1   | Телефон | 1200.00 | Самсунг     | 2      | 990.00    |
| 2   | Телефон | 1400.00 | Айфон       | 5      | 990.00    |


У товаров добавился столбец с средней ценой, по которому мы фильтруем.

### Оператор WITH

Для упрощения понимания некоторых запросов, мы можем применить оператор `WITH`. Который по сути будет являться переменной. В которую мы поместим какой-то запрос.

**Пример: Найти товары, дороже средней цены (но с WITH)**

```sql
WITH avg_price_cte AS (
    SELECT AVG(price) AS avg_price FROM products
)
SELECT * 
FROM products p, avg_price_cte 
WHERE p.price > avg_price_cte.avg_price;
```

**Что делает `WITH avg_price_cte`?**

`WITH` создаёт временную таблицу `avg_price_cte`, которая хранит `AVG(price)`. Основной запрос использует её в FROM, чтобы выбрать товары дороже средней цены. Результат – такой же, как в предыдущем примере.

## Объединение результатов: UNION, INTERSECT, EXCEPT

Иногда нужно объединить результаты разных SQL-запросов. Для этого используются:

| Оператор   | Описание                                                   |
|------------|------------------------------------------------------------|
| UNION      | Объединяет уникальные строки из двух запросов.             |
| UNION ALL  | Объединяет все строки, включая дубликаты.                  |
| INTERSECT  | Возвращает только совпадающие строки из двух запросов.     |
| EXCEPT     | Возвращает разницу (что есть в первом запросе, но нет во втором). |

### UNION 

Давайте объединеним товары и аксессуары. Допустим, у нас есть две таблицы:

```sql
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC
);

CREATE TABLE accessories (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    price NUMERIC
);
```

Мы хотим объединить товары и аксессуары в один список.

```sql
SELECT name, price FROM products
UNION
SELECT name, price FROM accessories;
```

`UNION` удаляет дубликаты.

Если хотим оставить дубликаты, используем `UNION ALL`:

```sql
SELECT name, price FROM products
UNION ALL
SELECT name, price FROM accessories;
```

### INTERSECT

Найдем товары и аксессуары с одинаковыми названиями

```sql
SELECT name FROM products
INTERSECT
SELECT name FROM accessories;
```

Покажет только те товары, которые есть и в `products`, и в `accessories`.

### EXCEPT 

Выведем товары, которых нет в аксессуарах

```sql
SELECT name FROM products
EXCEPT
SELECT name FROM accessories;
```

Покажет товары из `products`, которых нет в `accessories`.

## Оператор JOIN в SQL

![all_join.jpg](image/all_join.jpg)/


### Что такое JOIN и зачем он нужен?

В реальных базах данных данные часто распределены по разным таблицам. Чтобы получить полную картину, нам нужно объединять таблицы и получать данные из нескольких источников одновременно.

Простыми словами:

- Оператор JOIN позволяет связать несколько таблиц по определённому условию.
- Мы можем соединять таблицы по общему признаку (например, `id` пользователя в таблице `users` и `user_id` в таблице `orders`).

**Зачем это нужно?**

- Избегаем дублирования данных (например, не храним имя пользователя в каждой его покупке).
- Оптимизируем хранение (разделяем данные на логические блоки).
- Работаем с более сложными структурами.

Существует несколько типов JOIN:

- INNER JOIN
- LEFT JOIN (или LEFT OUTER JOIN)
- RIGHT JOIN (или RIGHT OUTER JOIN)
- FULL JOIN (или FULL OUTER JOIN)
- CROSS JOIN
- SELF JOIN

![Types-of-Join.webp](image/Types-of-Join.webp)

Создадим две таблицы для примеров. Для всех примеров будем использовать таблицы `users` и `orders`, которые представляют пользователей и их заказы.

```sql
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL
);

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INT,
    product VARCHAR(100) NOT NULL,
    amount NUMERIC(10,2) NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);
```

**Что здесь важно?**

- `users.id` – уникальный идентификатор пользователя (ключ PRIMARY KEY).
- `orders.user_id `– внешний ключ, который связывает заказ с пользователем (FOREIGN KEY REFERENCES users(id)).
- `ON DELETE CASCADE` – если пользователь удалится, его заказы тоже удалятся.

Наполним таблицы данными:

```sql
INSERT INTO users (name, email) VALUES
    ('Иван', 'ivan@example.com'),
    ('Мария', 'maria@example.com'),
    ('Алексей', 'alex@example.com'),
    ('Ольга', 'olga@example.com');

INSERT INTO orders (user_id, product, amount) VALUES
    (1, 'Телефон', 1200),
    (2, 'Ноутбук', 2500),
    (2, 'Мышь', 500),
    (3, 'Клавиатура', 1000),
    (5, 'Монитор', 3000); 
```

**Здесь `user_id = 5,` но такого пользователя нет в `users`!**

Проверяем содержимое таблиц

```sql
SELECT * FROM users;
```

| id | name    | email              |
|----|--------|--------------------|
| 1  | Иван   | ivan@example.com   |
| 2  | Мария  | maria@example.com  |
| 3  | Алексей| alex@example.com   |
| 4  | Ольга  | olga@example.com   |

```sql
SELECT * FROM orders;
```

| id | user_id | product   | amount |
|----|---------|----------|--------|
| 1  | 1       | Телефон  | 1200   |
| 2  | 2       | Ноутбук  | 2500   |
| 3  | 2       | Мышь     | 500    |
| 4  | 3       | Клавиатура | 1000  |
| 5  | 5       | Монитор  | 3000   |

**Важные моменты**

- У Ольги `(id = 4)` нет заказов – посмотрим, как она поведёт себя в `LEFT JOIN`.
- У `user_id = 5` есть заказ (Монитор), но такого пользователя нет в таблице `users` – посмотрим, что с ним будет в `RIGHT JOIN`.
- Теперь у нас есть готовая база, и можно выполнять JOIN-запросы!


### INNER JOIN

Этот JOIN вернёт только те строки, у которых есть совпадения в обеих таблицах. Если у пользователя нет заказов, он не попадёт в результат.

**SQL-запрос (INNER JOIN):**

```sql
SELECT users.name, users.email, orders.product, orders.amount
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```

Как это работает?

- SQL ищет совпадения между `users.id` и `orders.user_id`.
- Если в `orders` есть запись, но такого `user_id` нет в `users` – эта строка игнорируется.
- Если у пользователя нет заказов – он тоже не попадает в результат.

| name    | email              | product   | amount |
|--------|--------------------|----------|--------|
| Иван   | ivan@example.com   | Телефон  | 1200   |
| Мария  | maria@example.com  | Ноутбук  | 2500   |
| Мария  | maria@example.com  | Мышь     | 500    |
| Алексей| alex@example.com   | Клавиатура | 1000  |

**Что мы видим?**

- `Ольга (id = 4)` не попала в результат, потому что у неё нет заказов.
- Заказ Монитор `(user_id = 5)` тоже не попал, потому что такого пользователя нет в users.

### LEFT JOIN

`LEFT JOIN` возвращает все строки из левой таблицы и совпадающие строки из правой таблицы. Если совпадений нет, то возвращаются `NULL` для столбцов правой таблицы.

**SQL-запрос (LEFT JOIN):**

```sql
SELECT users.name, users.email, orders.product, orders.amount
FROM users
LEFT JOIN orders ON users.id = orders.user_id;
```

**Результат (LEFT JOIN):**

| name    | email              | product   | amount |
|--------|--------------------|----------|--------|
| Иван   | ivan@example.com   | Телефон  | 1200   |
| Мария  | maria@example.com  | Ноутбук  | 2500   |
| Мария  | maria@example.com  | Мышь     | 500    |
| Алексей| alex@example.com   | Клавиатура | 1000  |
| Ольга  | olga@example.com   | NULL     | NULL   |

**Что изменилось?**

- Ольга `(id = 4)` теперь есть в результатах, но у неё нет заказов, поэтому `product = NULL`.
- Заказ Монитор `(user_id = 5)` по-прежнему не попал в результат, потому что в users нет такого пользователя.

### RIGHT JOIN

`RIGHT JOIN` возвращает все строки из правой таблицы и совпадающие строки из левой таблицы. Если совпадений нет, то возвращаются `NULL` для столбцов левой таблицы.

**SQL-запрос (RIGHT JOIN):**

```sql
SELECT users.name, users.email, orders.product, orders.amount
FROM users
RIGHT JOIN orders ON users.id = orders.user_id;
```

**Результат (RIGHT JOIN):**

| name    | email              | product   | amount |
|--------|--------------------|----------|--------|
| Иван   | ivan@example.com   | Телефон  | 1200   |
| Мария  | maria@example.com  | Ноутбук  | 2500   |
| Мария  | maria@example.com  | Мышь     | 500    |
| Алексей| alex@example.com   | Клавиатура | 1000  |
| NULL   | NULL               | Монитор  | 3000   |

**Что изменилось?**

- Появился заказ на Монитор `(user_id = 5)`, но у него нет соответствующего пользователя → `NULL`.
- Ольга `(id = 4)` не попала в результат, так как у неё нет заказов.

### FULL JOIN

`FULL JOIN` возвращает все строки, когда есть совпадения в левой или правой таблицах. Если совпадений нет, то возвращаются `NULL` для отсутствующих совпадений с обеих сторон.

**SQL-запрос (FULL JOIN):**

```sql
SELECT users.name, users.email, orders.product, orders.amount
FROM users
FULL JOIN orders ON users.id = orders.user_id;
```

**Результат (FULL JOIN):**

| name    | email              | product   | amount |
|--------|--------------------|----------|--------|
| Иван   | ivan@example.com   | Телефон  | 1200   |
| Мария  | maria@example.com  | Ноутбук  | 2500   |
| Мария  | maria@example.com  | Мышь     | 500    |
| Алексей| alex@example.com   | Клавиатура | 1000  |
| Ольга  | olga@example.com   | NULL     | NULL   |
| NULL   | NULL               | Монитор  | 3000   |

Теперь у нас есть ВСЕ пользователи и ВСЕ заказы, даже если совпадений нет!

### CROSS JOIN

Этот `JOIN` создаёт "Декартово произведение", то есть каждую строку первой таблицы сочетает с каждой строкой второй таблицы.

Используется в редких случаях, например:

- Генерация тестовых данных
- Комбинации всех возможных параметров

**SQL-запрос (CROSS JOIN):**

```sql
SELECT users.name, orders.product
FROM users
CROSS JOIN orders;
```

**Как это работает?**

- Берём всех пользователей из users
- Берём все заказы из `orders`
- Создаём все возможные комбинации пользователей и заказов

| name    | product   |
|--------|----------|
| Иван   | Телефон  |
| Иван   | Ноутбук  |
| Иван   | Мышь     |
| Иван   | Клавиатура |
| Иван   | Монитор  |
| Мария  | Телефон  |
| Мария  | Ноутбук  |
| Мария  | Мышь     |
| Мария  | Клавиатура |
| Мария  | Монитор  |
| Алексей| Телефон  |
| Алексей| Ноутбук  |
| Алексей| Мышь     |
| Алексей| Клавиатура |
| Алексей| Монитор  |
| Ольга  | Телефон  |
| Ольга  | Ноутбук  |
| Ольга  | Мышь     |
| Ольга  | Клавиатура |
| Ольга  | Монитор  |

**Что произошло?**

- Каждому пользователю соответствуют все возможные заказы.
- У нас 4 пользователя × 5 заказов = 20 строк.

Использование `CROSS JOIN` может привести к огромному количеству строк, если таблицы большие!

### SELF JOIN

Этот JOIN позволяет сравнивать строки одной таблицы между собой. Часто используется для иерархических структур (например, сотрудники и их начальники).

**Создадим новую таблицу employees (Сотрудники)**

```sql
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    manager_id INT
);
```

**Добавим сотрудников:**

```sql
INSERT INTO employees (name, manager_id) VALUES
    ('Анна', NULL),   -- Анна - директор (без начальника)
    ('Иван', 1),      -- Иван подчиняется Анне
    ('Мария', 1),     -- Мария подчиняется Анне
    ('Алексей', 2),   -- Алексей подчиняется Ивану
    ('Ольга', 3);     -- Ольга подчиняется Марии
```

**Таблица employees (Сотрудники)**

| id | name    | manager_id |
|----|--------|-----------|
| 1  | Анна    | NULL      |
| 2  | Иван    | 1         |
| 3  | Мария   | 1         |
| 4  | Алексей | 2         |
| 5  | Ольга   | 3         |

**SQL-запрос (SELF JOIN):**

```sql
SELECT e1.name AS employee, e2.name AS manager
FROM employees e1
LEFT JOIN employees e2 ON e1.manager_id = e2.id;
```

**Как это работает?**

- e1 – сотрудник
- e2 – его начальник
- SQL ищет начальника для каждого сотрудника (manager_id = e2.id)

**Результат (SELF JOIN)**

| employee | manager |
|---------|--------|
| Анна     | NULL   |
| Иван     | Анна   |
| Мария    | Анна   |
| Алексей  | Иван   |
| Ольга    | Мария  |

**Что произошло?**

- Анна – директор, поэтому у неё нет начальника (NULL).
- Иван и Мария подчиняются Анне.
- Алексей подчиняется Ивану.
- Ольга подчиняется Марии.

Теперь у нас есть иерархия сотрудников!